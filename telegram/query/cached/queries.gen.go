// Code generated by itergen, DO NOT EDIT.

package cached

import (
	"context"
	"sync/atomic"

	"golang.org/x/xerrors"

	"github.com/gotd/td/tg"
)

// No-op definition for keeping imports.
var _ = context.Background()

type innerAccountGetChatThemes struct {
	// Last received hash.
	hash int
	// Last received result.
	value *tg.AccountChatThemes
}

type AccountGetChatThemes struct {
	// Result state.
	last atomic.Value

	// Reference to RPC client to make requests.
	raw *tg.Client
}

// NewAccountGetChatThemes creates new AccountGetChatThemes.
func NewAccountGetChatThemes(raw *tg.Client) *AccountGetChatThemes {
	q := &AccountGetChatThemes{
		raw: raw,
	}

	return q
}

func (s *AccountGetChatThemes) store(v innerAccountGetChatThemes) {
	s.last.Store(v)
}

func (s *AccountGetChatThemes) load() (innerAccountGetChatThemes, bool) {
	v, ok := s.last.Load().(innerAccountGetChatThemes)
	return v, ok
}

// Value returns last received result.
// NB: May be nil. Returned AccountChatThemes must not be mutated.
func (s *AccountGetChatThemes) Value() *tg.AccountChatThemes {
	inner, _ := s.load()
	return inner.value
}

// Hash returns last received hash.
func (s *AccountGetChatThemes) Hash() int {
	inner, _ := s.load()
	return inner.hash
}

// Get updates data if needed and returns it.
func (s *AccountGetChatThemes) Get(ctx context.Context) (*tg.AccountChatThemes, error) {
	if _, err := s.Fetch(ctx); err != nil {
		return nil, err
	}

	return s.Value(), nil
}

// Fetch updates data if needed and returns true if data was modified.
func (s *AccountGetChatThemes) Fetch(ctx context.Context) (bool, error) {
	lastHash := s.Hash()

	req := lastHash
	result, err := s.raw.AccountGetChatThemes(ctx, req)
	if err != nil {
		return false, xerrors.Errorf("execute AccountGetChatThemes: %w", err)
	}

	switch variant := result.(type) {
	case *tg.AccountChatThemes:
		hash := variant.Hash

		s.store(innerAccountGetChatThemes{
			hash:  hash,
			value: variant,
		})
		return true, nil
	case *tg.AccountChatThemesNotModified:
		if lastHash == 0 {
			return false, xerrors.Errorf("got unexpected %T result", result)
		}
		return false, nil
	default:
		return false, xerrors.Errorf("unexpected type %T", result)
	}
}

type innerHelpGetCountriesList struct {
	// Last received hash.
	hash int
	// Last received result.
	value *tg.HelpCountriesList
}

type HelpGetCountriesList struct {
	// Query to send.
	req *tg.HelpGetCountriesListRequest
	// Result state.
	last atomic.Value

	// Reference to RPC client to make requests.
	raw *tg.Client
}

// NewHelpGetCountriesList creates new HelpGetCountriesList.
func NewHelpGetCountriesList(raw *tg.Client, initial *tg.HelpGetCountriesListRequest) *HelpGetCountriesList {
	q := &HelpGetCountriesList{
		req: initial,
		raw: raw,
	}

	return q
}

func (s *HelpGetCountriesList) store(v innerHelpGetCountriesList) {
	s.last.Store(v)
}

func (s *HelpGetCountriesList) load() (innerHelpGetCountriesList, bool) {
	v, ok := s.last.Load().(innerHelpGetCountriesList)
	return v, ok
}

// Value returns last received result.
// NB: May be nil. Returned HelpCountriesList must not be mutated.
func (s *HelpGetCountriesList) Value() *tg.HelpCountriesList {
	inner, _ := s.load()
	return inner.value
}

// Hash returns last received hash.
func (s *HelpGetCountriesList) Hash() int {
	inner, _ := s.load()
	return inner.hash
}

// Get updates data if needed and returns it.
func (s *HelpGetCountriesList) Get(ctx context.Context) (*tg.HelpCountriesList, error) {
	if _, err := s.Fetch(ctx); err != nil {
		return nil, err
	}

	return s.Value(), nil
}

// Fetch updates data if needed and returns true if data was modified.
func (s *HelpGetCountriesList) Fetch(ctx context.Context) (bool, error) {
	lastHash := s.Hash()

	req := s.req
	req.Hash = lastHash
	result, err := s.raw.HelpGetCountriesList(ctx, req)
	if err != nil {
		return false, xerrors.Errorf("execute HelpGetCountriesList: %w", err)
	}

	switch variant := result.(type) {
	case *tg.HelpCountriesList:
		hash := variant.Hash

		s.store(innerHelpGetCountriesList{
			hash:  hash,
			value: variant,
		})
		return true, nil
	case *tg.HelpCountriesListNotModified:
		if lastHash == 0 {
			return false, xerrors.Errorf("got unexpected %T result", result)
		}
		return false, nil
	default:
		return false, xerrors.Errorf("unexpected type %T", result)
	}
}

type innerHelpGetPassportConfig struct {
	// Last received hash.
	hash int
	// Last received result.
	value *tg.HelpPassportConfig
}

type HelpGetPassportConfig struct {
	// Result state.
	last atomic.Value

	// Reference to RPC client to make requests.
	raw *tg.Client
}

// NewHelpGetPassportConfig creates new HelpGetPassportConfig.
func NewHelpGetPassportConfig(raw *tg.Client) *HelpGetPassportConfig {
	q := &HelpGetPassportConfig{
		raw: raw,
	}

	return q
}

func (s *HelpGetPassportConfig) store(v innerHelpGetPassportConfig) {
	s.last.Store(v)
}

func (s *HelpGetPassportConfig) load() (innerHelpGetPassportConfig, bool) {
	v, ok := s.last.Load().(innerHelpGetPassportConfig)
	return v, ok
}

// Value returns last received result.
// NB: May be nil. Returned HelpPassportConfig must not be mutated.
func (s *HelpGetPassportConfig) Value() *tg.HelpPassportConfig {
	inner, _ := s.load()
	return inner.value
}

// Hash returns last received hash.
func (s *HelpGetPassportConfig) Hash() int {
	inner, _ := s.load()
	return inner.hash
}

// Get updates data if needed and returns it.
func (s *HelpGetPassportConfig) Get(ctx context.Context) (*tg.HelpPassportConfig, error) {
	if _, err := s.Fetch(ctx); err != nil {
		return nil, err
	}

	return s.Value(), nil
}

// Fetch updates data if needed and returns true if data was modified.
func (s *HelpGetPassportConfig) Fetch(ctx context.Context) (bool, error) {
	lastHash := s.Hash()

	req := lastHash
	result, err := s.raw.HelpGetPassportConfig(ctx, req)
	if err != nil {
		return false, xerrors.Errorf("execute HelpGetPassportConfig: %w", err)
	}

	switch variant := result.(type) {
	case *tg.HelpPassportConfig:
		hash := variant.Hash

		s.store(innerHelpGetPassportConfig{
			hash:  hash,
			value: variant,
		})
		return true, nil
	case *tg.HelpPassportConfigNotModified:
		if lastHash == 0 {
			return false, xerrors.Errorf("got unexpected %T result", result)
		}
		return false, nil
	default:
		return false, xerrors.Errorf("unexpected type %T", result)
	}
}
