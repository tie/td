// Code generated by gotdgen, DO NOT EDIT.

package tg

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"github.com/gotd/td/bin"
	"github.com/gotd/td/tdp"
	"github.com/gotd/td/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
)

// ChannelParticipant represents TL type `channelParticipant#15ebac1d`.
// Channel/supergroup participant
//
// See https://core.telegram.org/constructor/channelParticipant for reference.
type ChannelParticipant struct {
	// Pariticipant user ID
	UserID int
	// Date joined
	Date int
}

// ChannelParticipantTypeID is TL type id of ChannelParticipant.
const ChannelParticipantTypeID = 0x15ebac1d

func (c *ChannelParticipant) Zero() bool {
	if c == nil {
		return true
	}
	if !(c.UserID == 0) {
		return false
	}
	if !(c.Date == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (c *ChannelParticipant) String() string {
	if c == nil {
		return "ChannelParticipant(nil)"
	}
	type Alias ChannelParticipant
	return fmt.Sprintf("ChannelParticipant%+v", Alias(*c))
}

// FillFrom fills ChannelParticipant from given interface.
func (c *ChannelParticipant) FillFrom(from interface {
	GetUserID() (value int)
	GetDate() (value int)
}) {
	c.UserID = from.GetUserID()
	c.Date = from.GetDate()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*ChannelParticipant) TypeID() uint32 {
	return ChannelParticipantTypeID
}

// TypeName returns name of type in TL schema.
func (*ChannelParticipant) TypeName() string {
	return "channelParticipant"
}

// TypeInfo returns info about TL type.
func (c *ChannelParticipant) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "channelParticipant",
		ID:   ChannelParticipantTypeID,
	}
	if c == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "UserID",
			SchemaName: "user_id",
		},
		{
			Name:       "Date",
			SchemaName: "date",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (c *ChannelParticipant) Encode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode channelParticipant#15ebac1d as nil")
	}
	b.PutID(ChannelParticipantTypeID)
	return c.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (c *ChannelParticipant) EncodeBare(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode channelParticipant#15ebac1d as nil")
	}
	b.PutInt(c.UserID)
	b.PutInt(c.Date)
	return nil
}

// GetUserID returns value of UserID field.
func (c *ChannelParticipant) GetUserID() (value int) {
	return c.UserID
}

// GetDate returns value of Date field.
func (c *ChannelParticipant) GetDate() (value int) {
	return c.Date
}

// Decode implements bin.Decoder.
func (c *ChannelParticipant) Decode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode channelParticipant#15ebac1d to nil")
	}
	if err := b.ConsumeID(ChannelParticipantTypeID); err != nil {
		return fmt.Errorf("unable to decode channelParticipant#15ebac1d: %w", err)
	}
	return c.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (c *ChannelParticipant) DecodeBare(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode channelParticipant#15ebac1d to nil")
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode channelParticipant#15ebac1d: field user_id: %w", err)
		}
		c.UserID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode channelParticipant#15ebac1d: field date: %w", err)
		}
		c.Date = value
	}
	return nil
}

// construct implements constructor of ChannelParticipantClass.
func (c ChannelParticipant) construct() ChannelParticipantClass { return &c }

// Ensuring interfaces in compile-time for ChannelParticipant.
var (
	_ bin.Encoder     = &ChannelParticipant{}
	_ bin.Decoder     = &ChannelParticipant{}
	_ bin.BareEncoder = &ChannelParticipant{}
	_ bin.BareDecoder = &ChannelParticipant{}

	_ ChannelParticipantClass = &ChannelParticipant{}
)

// ChannelParticipantSelf represents TL type `channelParticipantSelf#a3289a6d`.
// Myself
//
// See https://core.telegram.org/constructor/channelParticipantSelf for reference.
type ChannelParticipantSelf struct {
	// User ID
	UserID int
	// User that invited me to the channel/supergroup
	InviterID int
	// When did I join the channel/supergroup
	Date int
}

// ChannelParticipantSelfTypeID is TL type id of ChannelParticipantSelf.
const ChannelParticipantSelfTypeID = 0xa3289a6d

func (c *ChannelParticipantSelf) Zero() bool {
	if c == nil {
		return true
	}
	if !(c.UserID == 0) {
		return false
	}
	if !(c.InviterID == 0) {
		return false
	}
	if !(c.Date == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (c *ChannelParticipantSelf) String() string {
	if c == nil {
		return "ChannelParticipantSelf(nil)"
	}
	type Alias ChannelParticipantSelf
	return fmt.Sprintf("ChannelParticipantSelf%+v", Alias(*c))
}

// FillFrom fills ChannelParticipantSelf from given interface.
func (c *ChannelParticipantSelf) FillFrom(from interface {
	GetUserID() (value int)
	GetInviterID() (value int)
	GetDate() (value int)
}) {
	c.UserID = from.GetUserID()
	c.InviterID = from.GetInviterID()
	c.Date = from.GetDate()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*ChannelParticipantSelf) TypeID() uint32 {
	return ChannelParticipantSelfTypeID
}

// TypeName returns name of type in TL schema.
func (*ChannelParticipantSelf) TypeName() string {
	return "channelParticipantSelf"
}

// TypeInfo returns info about TL type.
func (c *ChannelParticipantSelf) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "channelParticipantSelf",
		ID:   ChannelParticipantSelfTypeID,
	}
	if c == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "UserID",
			SchemaName: "user_id",
		},
		{
			Name:       "InviterID",
			SchemaName: "inviter_id",
		},
		{
			Name:       "Date",
			SchemaName: "date",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (c *ChannelParticipantSelf) Encode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode channelParticipantSelf#a3289a6d as nil")
	}
	b.PutID(ChannelParticipantSelfTypeID)
	return c.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (c *ChannelParticipantSelf) EncodeBare(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode channelParticipantSelf#a3289a6d as nil")
	}
	b.PutInt(c.UserID)
	b.PutInt(c.InviterID)
	b.PutInt(c.Date)
	return nil
}

// GetUserID returns value of UserID field.
func (c *ChannelParticipantSelf) GetUserID() (value int) {
	return c.UserID
}

// GetInviterID returns value of InviterID field.
func (c *ChannelParticipantSelf) GetInviterID() (value int) {
	return c.InviterID
}

// GetDate returns value of Date field.
func (c *ChannelParticipantSelf) GetDate() (value int) {
	return c.Date
}

// Decode implements bin.Decoder.
func (c *ChannelParticipantSelf) Decode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode channelParticipantSelf#a3289a6d to nil")
	}
	if err := b.ConsumeID(ChannelParticipantSelfTypeID); err != nil {
		return fmt.Errorf("unable to decode channelParticipantSelf#a3289a6d: %w", err)
	}
	return c.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (c *ChannelParticipantSelf) DecodeBare(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode channelParticipantSelf#a3289a6d to nil")
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode channelParticipantSelf#a3289a6d: field user_id: %w", err)
		}
		c.UserID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode channelParticipantSelf#a3289a6d: field inviter_id: %w", err)
		}
		c.InviterID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode channelParticipantSelf#a3289a6d: field date: %w", err)
		}
		c.Date = value
	}
	return nil
}

// construct implements constructor of ChannelParticipantClass.
func (c ChannelParticipantSelf) construct() ChannelParticipantClass { return &c }

// Ensuring interfaces in compile-time for ChannelParticipantSelf.
var (
	_ bin.Encoder     = &ChannelParticipantSelf{}
	_ bin.Decoder     = &ChannelParticipantSelf{}
	_ bin.BareEncoder = &ChannelParticipantSelf{}
	_ bin.BareDecoder = &ChannelParticipantSelf{}

	_ ChannelParticipantClass = &ChannelParticipantSelf{}
)

// ChannelParticipantCreator represents TL type `channelParticipantCreator#447dca4b`.
// Channel/supergroup creator
//
// See https://core.telegram.org/constructor/channelParticipantCreator for reference.
type ChannelParticipantCreator struct {
	// Flags, see TL conditional fieldsÂ¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// User ID
	UserID int
	// Creator admin rights
	AdminRights ChatAdminRights
	// The role (rank) of the group creator in the group: just an arbitrary string, admin by default
	//
	// Use SetRank and GetRank helpers.
	Rank string
}

// ChannelParticipantCreatorTypeID is TL type id of ChannelParticipantCreator.
const ChannelParticipantCreatorTypeID = 0x447dca4b

func (c *ChannelParticipantCreator) Zero() bool {
	if c == nil {
		return true
	}
	if !(c.Flags.Zero()) {
		return false
	}
	if !(c.UserID == 0) {
		return false
	}
	if !(c.AdminRights.Zero()) {
		return false
	}
	if !(c.Rank == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (c *ChannelParticipantCreator) String() string {
	if c == nil {
		return "ChannelParticipantCreator(nil)"
	}
	type Alias ChannelParticipantCreator
	return fmt.Sprintf("ChannelParticipantCreator%+v", Alias(*c))
}

// FillFrom fills ChannelParticipantCreator from given interface.
func (c *ChannelParticipantCreator) FillFrom(from interface {
	GetUserID() (value int)
	GetAdminRights() (value ChatAdminRights)
	GetRank() (value string, ok bool)
}) {
	c.UserID = from.GetUserID()
	c.AdminRights = from.GetAdminRights()
	if val, ok := from.GetRank(); ok {
		c.Rank = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*ChannelParticipantCreator) TypeID() uint32 {
	return ChannelParticipantCreatorTypeID
}

// TypeName returns name of type in TL schema.
func (*ChannelParticipantCreator) TypeName() string {
	return "channelParticipantCreator"
}

// TypeInfo returns info about TL type.
func (c *ChannelParticipantCreator) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "channelParticipantCreator",
		ID:   ChannelParticipantCreatorTypeID,
	}
	if c == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "UserID",
			SchemaName: "user_id",
		},
		{
			Name:       "AdminRights",
			SchemaName: "admin_rights",
		},
		{
			Name:       "Rank",
			SchemaName: "rank",
			Null:       !c.Flags.Has(0),
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (c *ChannelParticipantCreator) Encode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode channelParticipantCreator#447dca4b as nil")
	}
	b.PutID(ChannelParticipantCreatorTypeID)
	return c.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (c *ChannelParticipantCreator) EncodeBare(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode channelParticipantCreator#447dca4b as nil")
	}
	if !(c.Rank == "") {
		c.Flags.Set(0)
	}
	if err := c.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode channelParticipantCreator#447dca4b: field flags: %w", err)
	}
	b.PutInt(c.UserID)
	if err := c.AdminRights.Encode(b); err != nil {
		return fmt.Errorf("unable to encode channelParticipantCreator#447dca4b: field admin_rights: %w", err)
	}
	if c.Flags.Has(0) {
		b.PutString(c.Rank)
	}
	return nil
}

// GetUserID returns value of UserID field.
func (c *ChannelParticipantCreator) GetUserID() (value int) {
	return c.UserID
}

// GetAdminRights returns value of AdminRights field.
func (c *ChannelParticipantCreator) GetAdminRights() (value ChatAdminRights) {
	return c.AdminRights
}

// SetRank sets value of Rank conditional field.
func (c *ChannelParticipantCreator) SetRank(value string) {
	c.Flags.Set(0)
	c.Rank = value
}

// GetRank returns value of Rank conditional field and
// boolean which is true if field was set.
func (c *ChannelParticipantCreator) GetRank() (value string, ok bool) {
	if !c.Flags.Has(0) {
		return value, false
	}
	return c.Rank, true
}

// Decode implements bin.Decoder.
func (c *ChannelParticipantCreator) Decode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode channelParticipantCreator#447dca4b to nil")
	}
	if err := b.ConsumeID(ChannelParticipantCreatorTypeID); err != nil {
		return fmt.Errorf("unable to decode channelParticipantCreator#447dca4b: %w", err)
	}
	return c.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (c *ChannelParticipantCreator) DecodeBare(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode channelParticipantCreator#447dca4b to nil")
	}
	{
		if err := c.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode channelParticipantCreator#447dca4b: field flags: %w", err)
		}
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode channelParticipantCreator#447dca4b: field user_id: %w", err)
		}
		c.UserID = value
	}
	{
		if err := c.AdminRights.Decode(b); err != nil {
			return fmt.Errorf("unable to decode channelParticipantCreator#447dca4b: field admin_rights: %w", err)
		}
	}
	if c.Flags.Has(0) {
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode channelParticipantCreator#447dca4b: field rank: %w", err)
		}
		c.Rank = value
	}
	return nil
}

// construct implements constructor of ChannelParticipantClass.
func (c ChannelParticipantCreator) construct() ChannelParticipantClass { return &c }

// Ensuring interfaces in compile-time for ChannelParticipantCreator.
var (
	_ bin.Encoder     = &ChannelParticipantCreator{}
	_ bin.Decoder     = &ChannelParticipantCreator{}
	_ bin.BareEncoder = &ChannelParticipantCreator{}
	_ bin.BareDecoder = &ChannelParticipantCreator{}

	_ ChannelParticipantClass = &ChannelParticipantCreator{}
)

// ChannelParticipantAdmin represents TL type `channelParticipantAdmin#ccbebbaf`.
// Admin
//
// See https://core.telegram.org/constructor/channelParticipantAdmin for reference.
type ChannelParticipantAdmin struct {
	// Flags, see TL conditional fieldsÂ¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Can this admin promote other admins with the same permissions?
	CanEdit bool
	// Is this the current user
	Self bool
	// Admin user ID
	UserID int
	// User that invited the admin to the channel/group
	//
	// Use SetInviterID and GetInviterID helpers.
	InviterID int
	// User that promoted the user to admin
	PromotedBy int
	// When did the user join
	Date int
	// Admin rightsÂ¹
	//
	// Links:
	//  1) https://core.telegram.org/api/rights
	AdminRights ChatAdminRights
	// The role (rank) of the admin in the group: just an arbitrary string, admin by default
	//
	// Use SetRank and GetRank helpers.
	Rank string
}

// ChannelParticipantAdminTypeID is TL type id of ChannelParticipantAdmin.
const ChannelParticipantAdminTypeID = 0xccbebbaf

func (c *ChannelParticipantAdmin) Zero() bool {
	if c == nil {
		return true
	}
	if !(c.Flags.Zero()) {
		return false
	}
	if !(c.CanEdit == false) {
		return false
	}
	if !(c.Self == false) {
		return false
	}
	if !(c.UserID == 0) {
		return false
	}
	if !(c.InviterID == 0) {
		return false
	}
	if !(c.PromotedBy == 0) {
		return false
	}
	if !(c.Date == 0) {
		return false
	}
	if !(c.AdminRights.Zero()) {
		return false
	}
	if !(c.Rank == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (c *ChannelParticipantAdmin) String() string {
	if c == nil {
		return "ChannelParticipantAdmin(nil)"
	}
	type Alias ChannelParticipantAdmin
	return fmt.Sprintf("ChannelParticipantAdmin%+v", Alias(*c))
}

// FillFrom fills ChannelParticipantAdmin from given interface.
func (c *ChannelParticipantAdmin) FillFrom(from interface {
	GetCanEdit() (value bool)
	GetSelf() (value bool)
	GetUserID() (value int)
	GetInviterID() (value int, ok bool)
	GetPromotedBy() (value int)
	GetDate() (value int)
	GetAdminRights() (value ChatAdminRights)
	GetRank() (value string, ok bool)
}) {
	c.CanEdit = from.GetCanEdit()
	c.Self = from.GetSelf()
	c.UserID = from.GetUserID()
	if val, ok := from.GetInviterID(); ok {
		c.InviterID = val
	}

	c.PromotedBy = from.GetPromotedBy()
	c.Date = from.GetDate()
	c.AdminRights = from.GetAdminRights()
	if val, ok := from.GetRank(); ok {
		c.Rank = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*ChannelParticipantAdmin) TypeID() uint32 {
	return ChannelParticipantAdminTypeID
}

// TypeName returns name of type in TL schema.
func (*ChannelParticipantAdmin) TypeName() string {
	return "channelParticipantAdmin"
}

// TypeInfo returns info about TL type.
func (c *ChannelParticipantAdmin) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "channelParticipantAdmin",
		ID:   ChannelParticipantAdminTypeID,
	}
	if c == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "CanEdit",
			SchemaName: "can_edit",
			Null:       !c.Flags.Has(0),
		},
		{
			Name:       "Self",
			SchemaName: "self",
			Null:       !c.Flags.Has(1),
		},
		{
			Name:       "UserID",
			SchemaName: "user_id",
		},
		{
			Name:       "InviterID",
			SchemaName: "inviter_id",
			Null:       !c.Flags.Has(1),
		},
		{
			Name:       "PromotedBy",
			SchemaName: "promoted_by",
		},
		{
			Name:       "Date",
			SchemaName: "date",
		},
		{
			Name:       "AdminRights",
			SchemaName: "admin_rights",
		},
		{
			Name:       "Rank",
			SchemaName: "rank",
			Null:       !c.Flags.Has(2),
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (c *ChannelParticipantAdmin) Encode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode channelParticipantAdmin#ccbebbaf as nil")
	}
	b.PutID(ChannelParticipantAdminTypeID)
	return c.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (c *ChannelParticipantAdmin) EncodeBare(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode channelParticipantAdmin#ccbebbaf as nil")
	}
	if !(c.CanEdit == false) {
		c.Flags.Set(0)
	}
	if !(c.Self == false) {
		c.Flags.Set(1)
	}
	if !(c.InviterID == 0) {
		c.Flags.Set(1)
	}
	if !(c.Rank == "") {
		c.Flags.Set(2)
	}
	if err := c.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode channelParticipantAdmin#ccbebbaf: field flags: %w", err)
	}
	b.PutInt(c.UserID)
	if c.Flags.Has(1) {
		b.PutInt(c.InviterID)
	}
	b.PutInt(c.PromotedBy)
	b.PutInt(c.Date)
	if err := c.AdminRights.Encode(b); err != nil {
		return fmt.Errorf("unable to encode channelParticipantAdmin#ccbebbaf: field admin_rights: %w", err)
	}
	if c.Flags.Has(2) {
		b.PutString(c.Rank)
	}
	return nil
}

// SetCanEdit sets value of CanEdit conditional field.
func (c *ChannelParticipantAdmin) SetCanEdit(value bool) {
	if value {
		c.Flags.Set(0)
		c.CanEdit = true
	} else {
		c.Flags.Unset(0)
		c.CanEdit = false
	}
}

// GetCanEdit returns value of CanEdit conditional field.
func (c *ChannelParticipantAdmin) GetCanEdit() (value bool) {
	return c.Flags.Has(0)
}

// SetSelf sets value of Self conditional field.
func (c *ChannelParticipantAdmin) SetSelf(value bool) {
	if value {
		c.Flags.Set(1)
		c.Self = true
	} else {
		c.Flags.Unset(1)
		c.Self = false
	}
}

// GetSelf returns value of Self conditional field.
func (c *ChannelParticipantAdmin) GetSelf() (value bool) {
	return c.Flags.Has(1)
}

// GetUserID returns value of UserID field.
func (c *ChannelParticipantAdmin) GetUserID() (value int) {
	return c.UserID
}

// SetInviterID sets value of InviterID conditional field.
func (c *ChannelParticipantAdmin) SetInviterID(value int) {
	c.Flags.Set(1)
	c.InviterID = value
}

// GetInviterID returns value of InviterID conditional field and
// boolean which is true if field was set.
func (c *ChannelParticipantAdmin) GetInviterID() (value int, ok bool) {
	if !c.Flags.Has(1) {
		return value, false
	}
	return c.InviterID, true
}

// GetPromotedBy returns value of PromotedBy field.
func (c *ChannelParticipantAdmin) GetPromotedBy() (value int) {
	return c.PromotedBy
}

// GetDate returns value of Date field.
func (c *ChannelParticipantAdmin) GetDate() (value int) {
	return c.Date
}

// GetAdminRights returns value of AdminRights field.
func (c *ChannelParticipantAdmin) GetAdminRights() (value ChatAdminRights) {
	return c.AdminRights
}

// SetRank sets value of Rank conditional field.
func (c *ChannelParticipantAdmin) SetRank(value string) {
	c.Flags.Set(2)
	c.Rank = value
}

// GetRank returns value of Rank conditional field and
// boolean which is true if field was set.
func (c *ChannelParticipantAdmin) GetRank() (value string, ok bool) {
	if !c.Flags.Has(2) {
		return value, false
	}
	return c.Rank, true
}

// Decode implements bin.Decoder.
func (c *ChannelParticipantAdmin) Decode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode channelParticipantAdmin#ccbebbaf to nil")
	}
	if err := b.ConsumeID(ChannelParticipantAdminTypeID); err != nil {
		return fmt.Errorf("unable to decode channelParticipantAdmin#ccbebbaf: %w", err)
	}
	return c.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (c *ChannelParticipantAdmin) DecodeBare(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode channelParticipantAdmin#ccbebbaf to nil")
	}
	{
		if err := c.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode channelParticipantAdmin#ccbebbaf: field flags: %w", err)
		}
	}
	c.CanEdit = c.Flags.Has(0)
	c.Self = c.Flags.Has(1)
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode channelParticipantAdmin#ccbebbaf: field user_id: %w", err)
		}
		c.UserID = value
	}
	if c.Flags.Has(1) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode channelParticipantAdmin#ccbebbaf: field inviter_id: %w", err)
		}
		c.InviterID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode channelParticipantAdmin#ccbebbaf: field promoted_by: %w", err)
		}
		c.PromotedBy = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode channelParticipantAdmin#ccbebbaf: field date: %w", err)
		}
		c.Date = value
	}
	{
		if err := c.AdminRights.Decode(b); err != nil {
			return fmt.Errorf("unable to decode channelParticipantAdmin#ccbebbaf: field admin_rights: %w", err)
		}
	}
	if c.Flags.Has(2) {
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode channelParticipantAdmin#ccbebbaf: field rank: %w", err)
		}
		c.Rank = value
	}
	return nil
}

// construct implements constructor of ChannelParticipantClass.
func (c ChannelParticipantAdmin) construct() ChannelParticipantClass { return &c }

// Ensuring interfaces in compile-time for ChannelParticipantAdmin.
var (
	_ bin.Encoder     = &ChannelParticipantAdmin{}
	_ bin.Decoder     = &ChannelParticipantAdmin{}
	_ bin.BareEncoder = &ChannelParticipantAdmin{}
	_ bin.BareDecoder = &ChannelParticipantAdmin{}

	_ ChannelParticipantClass = &ChannelParticipantAdmin{}
)

// ChannelParticipantBanned represents TL type `channelParticipantBanned#50a1dfd6`.
// Banned/kicked user
//
// See https://core.telegram.org/constructor/channelParticipantBanned for reference.
type ChannelParticipantBanned struct {
	// Flags, see TL conditional fieldsÂ¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Whether the user has left the group
	Left bool
	// Peer field of ChannelParticipantBanned.
	Peer PeerClass
	// User was kicked by the specified admin
	KickedBy int
	// When did the user join the group
	Date int
	// Banned rightsÂ¹
	//
	// Links:
	//  1) https://core.telegram.org/api/rights
	BannedRights ChatBannedRights
}

// ChannelParticipantBannedTypeID is TL type id of ChannelParticipantBanned.
const ChannelParticipantBannedTypeID = 0x50a1dfd6

func (c *ChannelParticipantBanned) Zero() bool {
	if c == nil {
		return true
	}
	if !(c.Flags.Zero()) {
		return false
	}
	if !(c.Left == false) {
		return false
	}
	if !(c.Peer == nil) {
		return false
	}
	if !(c.KickedBy == 0) {
		return false
	}
	if !(c.Date == 0) {
		return false
	}
	if !(c.BannedRights.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (c *ChannelParticipantBanned) String() string {
	if c == nil {
		return "ChannelParticipantBanned(nil)"
	}
	type Alias ChannelParticipantBanned
	return fmt.Sprintf("ChannelParticipantBanned%+v", Alias(*c))
}

// FillFrom fills ChannelParticipantBanned from given interface.
func (c *ChannelParticipantBanned) FillFrom(from interface {
	GetLeft() (value bool)
	GetPeer() (value PeerClass)
	GetKickedBy() (value int)
	GetDate() (value int)
	GetBannedRights() (value ChatBannedRights)
}) {
	c.Left = from.GetLeft()
	c.Peer = from.GetPeer()
	c.KickedBy = from.GetKickedBy()
	c.Date = from.GetDate()
	c.BannedRights = from.GetBannedRights()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*ChannelParticipantBanned) TypeID() uint32 {
	return ChannelParticipantBannedTypeID
}

// TypeName returns name of type in TL schema.
func (*ChannelParticipantBanned) TypeName() string {
	return "channelParticipantBanned"
}

// TypeInfo returns info about TL type.
func (c *ChannelParticipantBanned) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "channelParticipantBanned",
		ID:   ChannelParticipantBannedTypeID,
	}
	if c == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Left",
			SchemaName: "left",
			Null:       !c.Flags.Has(0),
		},
		{
			Name:       "Peer",
			SchemaName: "peer",
		},
		{
			Name:       "KickedBy",
			SchemaName: "kicked_by",
		},
		{
			Name:       "Date",
			SchemaName: "date",
		},
		{
			Name:       "BannedRights",
			SchemaName: "banned_rights",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (c *ChannelParticipantBanned) Encode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode channelParticipantBanned#50a1dfd6 as nil")
	}
	b.PutID(ChannelParticipantBannedTypeID)
	return c.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (c *ChannelParticipantBanned) EncodeBare(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode channelParticipantBanned#50a1dfd6 as nil")
	}
	if !(c.Left == false) {
		c.Flags.Set(0)
	}
	if err := c.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode channelParticipantBanned#50a1dfd6: field flags: %w", err)
	}
	if c.Peer == nil {
		return fmt.Errorf("unable to encode channelParticipantBanned#50a1dfd6: field peer is nil")
	}
	if err := c.Peer.Encode(b); err != nil {
		return fmt.Errorf("unable to encode channelParticipantBanned#50a1dfd6: field peer: %w", err)
	}
	b.PutInt(c.KickedBy)
	b.PutInt(c.Date)
	if err := c.BannedRights.Encode(b); err != nil {
		return fmt.Errorf("unable to encode channelParticipantBanned#50a1dfd6: field banned_rights: %w", err)
	}
	return nil
}

// SetLeft sets value of Left conditional field.
func (c *ChannelParticipantBanned) SetLeft(value bool) {
	if value {
		c.Flags.Set(0)
		c.Left = true
	} else {
		c.Flags.Unset(0)
		c.Left = false
	}
}

// GetLeft returns value of Left conditional field.
func (c *ChannelParticipantBanned) GetLeft() (value bool) {
	return c.Flags.Has(0)
}

// GetPeer returns value of Peer field.
func (c *ChannelParticipantBanned) GetPeer() (value PeerClass) {
	return c.Peer
}

// GetKickedBy returns value of KickedBy field.
func (c *ChannelParticipantBanned) GetKickedBy() (value int) {
	return c.KickedBy
}

// GetDate returns value of Date field.
func (c *ChannelParticipantBanned) GetDate() (value int) {
	return c.Date
}

// GetBannedRights returns value of BannedRights field.
func (c *ChannelParticipantBanned) GetBannedRights() (value ChatBannedRights) {
	return c.BannedRights
}

// Decode implements bin.Decoder.
func (c *ChannelParticipantBanned) Decode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode channelParticipantBanned#50a1dfd6 to nil")
	}
	if err := b.ConsumeID(ChannelParticipantBannedTypeID); err != nil {
		return fmt.Errorf("unable to decode channelParticipantBanned#50a1dfd6: %w", err)
	}
	return c.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (c *ChannelParticipantBanned) DecodeBare(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode channelParticipantBanned#50a1dfd6 to nil")
	}
	{
		if err := c.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode channelParticipantBanned#50a1dfd6: field flags: %w", err)
		}
	}
	c.Left = c.Flags.Has(0)
	{
		value, err := DecodePeer(b)
		if err != nil {
			return fmt.Errorf("unable to decode channelParticipantBanned#50a1dfd6: field peer: %w", err)
		}
		c.Peer = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode channelParticipantBanned#50a1dfd6: field kicked_by: %w", err)
		}
		c.KickedBy = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode channelParticipantBanned#50a1dfd6: field date: %w", err)
		}
		c.Date = value
	}
	{
		if err := c.BannedRights.Decode(b); err != nil {
			return fmt.Errorf("unable to decode channelParticipantBanned#50a1dfd6: field banned_rights: %w", err)
		}
	}
	return nil
}

// construct implements constructor of ChannelParticipantClass.
func (c ChannelParticipantBanned) construct() ChannelParticipantClass { return &c }

// Ensuring interfaces in compile-time for ChannelParticipantBanned.
var (
	_ bin.Encoder     = &ChannelParticipantBanned{}
	_ bin.Decoder     = &ChannelParticipantBanned{}
	_ bin.BareEncoder = &ChannelParticipantBanned{}
	_ bin.BareDecoder = &ChannelParticipantBanned{}

	_ ChannelParticipantClass = &ChannelParticipantBanned{}
)

// ChannelParticipantLeft represents TL type `channelParticipantLeft#1b03f006`.
// A participant that left the channel/supergroup
//
// See https://core.telegram.org/constructor/channelParticipantLeft for reference.
type ChannelParticipantLeft struct {
	// Peer field of ChannelParticipantLeft.
	Peer PeerClass
}

// ChannelParticipantLeftTypeID is TL type id of ChannelParticipantLeft.
const ChannelParticipantLeftTypeID = 0x1b03f006

func (c *ChannelParticipantLeft) Zero() bool {
	if c == nil {
		return true
	}
	if !(c.Peer == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (c *ChannelParticipantLeft) String() string {
	if c == nil {
		return "ChannelParticipantLeft(nil)"
	}
	type Alias ChannelParticipantLeft
	return fmt.Sprintf("ChannelParticipantLeft%+v", Alias(*c))
}

// FillFrom fills ChannelParticipantLeft from given interface.
func (c *ChannelParticipantLeft) FillFrom(from interface {
	GetPeer() (value PeerClass)
}) {
	c.Peer = from.GetPeer()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*ChannelParticipantLeft) TypeID() uint32 {
	return ChannelParticipantLeftTypeID
}

// TypeName returns name of type in TL schema.
func (*ChannelParticipantLeft) TypeName() string {
	return "channelParticipantLeft"
}

// TypeInfo returns info about TL type.
func (c *ChannelParticipantLeft) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "channelParticipantLeft",
		ID:   ChannelParticipantLeftTypeID,
	}
	if c == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Peer",
			SchemaName: "peer",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (c *ChannelParticipantLeft) Encode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode channelParticipantLeft#1b03f006 as nil")
	}
	b.PutID(ChannelParticipantLeftTypeID)
	return c.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (c *ChannelParticipantLeft) EncodeBare(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode channelParticipantLeft#1b03f006 as nil")
	}
	if c.Peer == nil {
		return fmt.Errorf("unable to encode channelParticipantLeft#1b03f006: field peer is nil")
	}
	if err := c.Peer.Encode(b); err != nil {
		return fmt.Errorf("unable to encode channelParticipantLeft#1b03f006: field peer: %w", err)
	}
	return nil
}

// GetPeer returns value of Peer field.
func (c *ChannelParticipantLeft) GetPeer() (value PeerClass) {
	return c.Peer
}

// Decode implements bin.Decoder.
func (c *ChannelParticipantLeft) Decode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode channelParticipantLeft#1b03f006 to nil")
	}
	if err := b.ConsumeID(ChannelParticipantLeftTypeID); err != nil {
		return fmt.Errorf("unable to decode channelParticipantLeft#1b03f006: %w", err)
	}
	return c.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (c *ChannelParticipantLeft) DecodeBare(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode channelParticipantLeft#1b03f006 to nil")
	}
	{
		value, err := DecodePeer(b)
		if err != nil {
			return fmt.Errorf("unable to decode channelParticipantLeft#1b03f006: field peer: %w", err)
		}
		c.Peer = value
	}
	return nil
}

// construct implements constructor of ChannelParticipantClass.
func (c ChannelParticipantLeft) construct() ChannelParticipantClass { return &c }

// Ensuring interfaces in compile-time for ChannelParticipantLeft.
var (
	_ bin.Encoder     = &ChannelParticipantLeft{}
	_ bin.Decoder     = &ChannelParticipantLeft{}
	_ bin.BareEncoder = &ChannelParticipantLeft{}
	_ bin.BareDecoder = &ChannelParticipantLeft{}

	_ ChannelParticipantClass = &ChannelParticipantLeft{}
)

// ChannelParticipantClass represents ChannelParticipant generic type.
//
// See https://core.telegram.org/type/ChannelParticipant for reference.
//
// Example:
//  g, err := tg.DecodeChannelParticipant(buf)
//  if err != nil {
//      panic(err)
//  }
//  switch v := g.(type) {
//  case *tg.ChannelParticipant: // channelParticipant#15ebac1d
//  case *tg.ChannelParticipantSelf: // channelParticipantSelf#a3289a6d
//  case *tg.ChannelParticipantCreator: // channelParticipantCreator#447dca4b
//  case *tg.ChannelParticipantAdmin: // channelParticipantAdmin#ccbebbaf
//  case *tg.ChannelParticipantBanned: // channelParticipantBanned#50a1dfd6
//  case *tg.ChannelParticipantLeft: // channelParticipantLeft#1b03f006
//  default: panic(v)
//  }
type ChannelParticipantClass interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	construct() ChannelParticipantClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool
}

// DecodeChannelParticipant implements binary de-serialization for ChannelParticipantClass.
func DecodeChannelParticipant(buf *bin.Buffer) (ChannelParticipantClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case ChannelParticipantTypeID:
		// Decoding channelParticipant#15ebac1d.
		v := ChannelParticipant{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode ChannelParticipantClass: %w", err)
		}
		return &v, nil
	case ChannelParticipantSelfTypeID:
		// Decoding channelParticipantSelf#a3289a6d.
		v := ChannelParticipantSelf{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode ChannelParticipantClass: %w", err)
		}
		return &v, nil
	case ChannelParticipantCreatorTypeID:
		// Decoding channelParticipantCreator#447dca4b.
		v := ChannelParticipantCreator{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode ChannelParticipantClass: %w", err)
		}
		return &v, nil
	case ChannelParticipantAdminTypeID:
		// Decoding channelParticipantAdmin#ccbebbaf.
		v := ChannelParticipantAdmin{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode ChannelParticipantClass: %w", err)
		}
		return &v, nil
	case ChannelParticipantBannedTypeID:
		// Decoding channelParticipantBanned#50a1dfd6.
		v := ChannelParticipantBanned{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode ChannelParticipantClass: %w", err)
		}
		return &v, nil
	case ChannelParticipantLeftTypeID:
		// Decoding channelParticipantLeft#1b03f006.
		v := ChannelParticipantLeft{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode ChannelParticipantClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode ChannelParticipantClass: %w", bin.NewUnexpectedID(id))
	}
}

// ChannelParticipant boxes the ChannelParticipantClass providing a helper.
type ChannelParticipantBox struct {
	ChannelParticipant ChannelParticipantClass
}

// Decode implements bin.Decoder for ChannelParticipantBox.
func (b *ChannelParticipantBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode ChannelParticipantBox to nil")
	}
	v, err := DecodeChannelParticipant(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.ChannelParticipant = v
	return nil
}

// Encode implements bin.Encode for ChannelParticipantBox.
func (b *ChannelParticipantBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.ChannelParticipant == nil {
		return fmt.Errorf("unable to encode ChannelParticipantClass as nil")
	}
	return b.ChannelParticipant.Encode(buf)
}

// ChannelParticipantClassArray is adapter for slice of ChannelParticipantClass.
type ChannelParticipantClassArray []ChannelParticipantClass

// Sort sorts slice of ChannelParticipantClass.
func (s ChannelParticipantClassArray) Sort(less func(a, b ChannelParticipantClass) bool) ChannelParticipantClassArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of ChannelParticipantClass.
func (s ChannelParticipantClassArray) SortStable(less func(a, b ChannelParticipantClass) bool) ChannelParticipantClassArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of ChannelParticipantClass.
func (s ChannelParticipantClassArray) Retain(keep func(x ChannelParticipantClass) bool) ChannelParticipantClassArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s ChannelParticipantClassArray) First() (v ChannelParticipantClass, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s ChannelParticipantClassArray) Last() (v ChannelParticipantClass, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *ChannelParticipantClassArray) PopFirst() (v ChannelParticipantClass, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero ChannelParticipantClass
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *ChannelParticipantClassArray) Pop() (v ChannelParticipantClass, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// AsChannelParticipant returns copy with only ChannelParticipant constructors.
func (s ChannelParticipantClassArray) AsChannelParticipant() (to ChannelParticipantArray) {
	for _, elem := range s {
		value, ok := elem.(*ChannelParticipant)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsChannelParticipantSelf returns copy with only ChannelParticipantSelf constructors.
func (s ChannelParticipantClassArray) AsChannelParticipantSelf() (to ChannelParticipantSelfArray) {
	for _, elem := range s {
		value, ok := elem.(*ChannelParticipantSelf)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsChannelParticipantCreator returns copy with only ChannelParticipantCreator constructors.
func (s ChannelParticipantClassArray) AsChannelParticipantCreator() (to ChannelParticipantCreatorArray) {
	for _, elem := range s {
		value, ok := elem.(*ChannelParticipantCreator)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsChannelParticipantAdmin returns copy with only ChannelParticipantAdmin constructors.
func (s ChannelParticipantClassArray) AsChannelParticipantAdmin() (to ChannelParticipantAdminArray) {
	for _, elem := range s {
		value, ok := elem.(*ChannelParticipantAdmin)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsChannelParticipantBanned returns copy with only ChannelParticipantBanned constructors.
func (s ChannelParticipantClassArray) AsChannelParticipantBanned() (to ChannelParticipantBannedArray) {
	for _, elem := range s {
		value, ok := elem.(*ChannelParticipantBanned)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsChannelParticipantLeft returns copy with only ChannelParticipantLeft constructors.
func (s ChannelParticipantClassArray) AsChannelParticipantLeft() (to ChannelParticipantLeftArray) {
	for _, elem := range s {
		value, ok := elem.(*ChannelParticipantLeft)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// ChannelParticipantArray is adapter for slice of ChannelParticipant.
type ChannelParticipantArray []ChannelParticipant

// Sort sorts slice of ChannelParticipant.
func (s ChannelParticipantArray) Sort(less func(a, b ChannelParticipant) bool) ChannelParticipantArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of ChannelParticipant.
func (s ChannelParticipantArray) SortStable(less func(a, b ChannelParticipant) bool) ChannelParticipantArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of ChannelParticipant.
func (s ChannelParticipantArray) Retain(keep func(x ChannelParticipant) bool) ChannelParticipantArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s ChannelParticipantArray) First() (v ChannelParticipant, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s ChannelParticipantArray) Last() (v ChannelParticipant, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *ChannelParticipantArray) PopFirst() (v ChannelParticipant, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero ChannelParticipant
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *ChannelParticipantArray) Pop() (v ChannelParticipant, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByDate sorts slice of ChannelParticipant by Date.
func (s ChannelParticipantArray) SortByDate() ChannelParticipantArray {
	return s.Sort(func(a, b ChannelParticipant) bool {
		return a.GetDate() < b.GetDate()
	})
}

// SortStableByDate sorts slice of ChannelParticipant by Date.
func (s ChannelParticipantArray) SortStableByDate() ChannelParticipantArray {
	return s.SortStable(func(a, b ChannelParticipant) bool {
		return a.GetDate() < b.GetDate()
	})
}

// ChannelParticipantSelfArray is adapter for slice of ChannelParticipantSelf.
type ChannelParticipantSelfArray []ChannelParticipantSelf

// Sort sorts slice of ChannelParticipantSelf.
func (s ChannelParticipantSelfArray) Sort(less func(a, b ChannelParticipantSelf) bool) ChannelParticipantSelfArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of ChannelParticipantSelf.
func (s ChannelParticipantSelfArray) SortStable(less func(a, b ChannelParticipantSelf) bool) ChannelParticipantSelfArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of ChannelParticipantSelf.
func (s ChannelParticipantSelfArray) Retain(keep func(x ChannelParticipantSelf) bool) ChannelParticipantSelfArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s ChannelParticipantSelfArray) First() (v ChannelParticipantSelf, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s ChannelParticipantSelfArray) Last() (v ChannelParticipantSelf, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *ChannelParticipantSelfArray) PopFirst() (v ChannelParticipantSelf, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero ChannelParticipantSelf
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *ChannelParticipantSelfArray) Pop() (v ChannelParticipantSelf, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByDate sorts slice of ChannelParticipantSelf by Date.
func (s ChannelParticipantSelfArray) SortByDate() ChannelParticipantSelfArray {
	return s.Sort(func(a, b ChannelParticipantSelf) bool {
		return a.GetDate() < b.GetDate()
	})
}

// SortStableByDate sorts slice of ChannelParticipantSelf by Date.
func (s ChannelParticipantSelfArray) SortStableByDate() ChannelParticipantSelfArray {
	return s.SortStable(func(a, b ChannelParticipantSelf) bool {
		return a.GetDate() < b.GetDate()
	})
}

// ChannelParticipantCreatorArray is adapter for slice of ChannelParticipantCreator.
type ChannelParticipantCreatorArray []ChannelParticipantCreator

// Sort sorts slice of ChannelParticipantCreator.
func (s ChannelParticipantCreatorArray) Sort(less func(a, b ChannelParticipantCreator) bool) ChannelParticipantCreatorArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of ChannelParticipantCreator.
func (s ChannelParticipantCreatorArray) SortStable(less func(a, b ChannelParticipantCreator) bool) ChannelParticipantCreatorArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of ChannelParticipantCreator.
func (s ChannelParticipantCreatorArray) Retain(keep func(x ChannelParticipantCreator) bool) ChannelParticipantCreatorArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s ChannelParticipantCreatorArray) First() (v ChannelParticipantCreator, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s ChannelParticipantCreatorArray) Last() (v ChannelParticipantCreator, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *ChannelParticipantCreatorArray) PopFirst() (v ChannelParticipantCreator, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero ChannelParticipantCreator
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *ChannelParticipantCreatorArray) Pop() (v ChannelParticipantCreator, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// ChannelParticipantAdminArray is adapter for slice of ChannelParticipantAdmin.
type ChannelParticipantAdminArray []ChannelParticipantAdmin

// Sort sorts slice of ChannelParticipantAdmin.
func (s ChannelParticipantAdminArray) Sort(less func(a, b ChannelParticipantAdmin) bool) ChannelParticipantAdminArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of ChannelParticipantAdmin.
func (s ChannelParticipantAdminArray) SortStable(less func(a, b ChannelParticipantAdmin) bool) ChannelParticipantAdminArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of ChannelParticipantAdmin.
func (s ChannelParticipantAdminArray) Retain(keep func(x ChannelParticipantAdmin) bool) ChannelParticipantAdminArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s ChannelParticipantAdminArray) First() (v ChannelParticipantAdmin, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s ChannelParticipantAdminArray) Last() (v ChannelParticipantAdmin, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *ChannelParticipantAdminArray) PopFirst() (v ChannelParticipantAdmin, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero ChannelParticipantAdmin
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *ChannelParticipantAdminArray) Pop() (v ChannelParticipantAdmin, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByDate sorts slice of ChannelParticipantAdmin by Date.
func (s ChannelParticipantAdminArray) SortByDate() ChannelParticipantAdminArray {
	return s.Sort(func(a, b ChannelParticipantAdmin) bool {
		return a.GetDate() < b.GetDate()
	})
}

// SortStableByDate sorts slice of ChannelParticipantAdmin by Date.
func (s ChannelParticipantAdminArray) SortStableByDate() ChannelParticipantAdminArray {
	return s.SortStable(func(a, b ChannelParticipantAdmin) bool {
		return a.GetDate() < b.GetDate()
	})
}

// ChannelParticipantBannedArray is adapter for slice of ChannelParticipantBanned.
type ChannelParticipantBannedArray []ChannelParticipantBanned

// Sort sorts slice of ChannelParticipantBanned.
func (s ChannelParticipantBannedArray) Sort(less func(a, b ChannelParticipantBanned) bool) ChannelParticipantBannedArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of ChannelParticipantBanned.
func (s ChannelParticipantBannedArray) SortStable(less func(a, b ChannelParticipantBanned) bool) ChannelParticipantBannedArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of ChannelParticipantBanned.
func (s ChannelParticipantBannedArray) Retain(keep func(x ChannelParticipantBanned) bool) ChannelParticipantBannedArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s ChannelParticipantBannedArray) First() (v ChannelParticipantBanned, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s ChannelParticipantBannedArray) Last() (v ChannelParticipantBanned, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *ChannelParticipantBannedArray) PopFirst() (v ChannelParticipantBanned, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero ChannelParticipantBanned
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *ChannelParticipantBannedArray) Pop() (v ChannelParticipantBanned, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByDate sorts slice of ChannelParticipantBanned by Date.
func (s ChannelParticipantBannedArray) SortByDate() ChannelParticipantBannedArray {
	return s.Sort(func(a, b ChannelParticipantBanned) bool {
		return a.GetDate() < b.GetDate()
	})
}

// SortStableByDate sorts slice of ChannelParticipantBanned by Date.
func (s ChannelParticipantBannedArray) SortStableByDate() ChannelParticipantBannedArray {
	return s.SortStable(func(a, b ChannelParticipantBanned) bool {
		return a.GetDate() < b.GetDate()
	})
}

// ChannelParticipantLeftArray is adapter for slice of ChannelParticipantLeft.
type ChannelParticipantLeftArray []ChannelParticipantLeft

// Sort sorts slice of ChannelParticipantLeft.
func (s ChannelParticipantLeftArray) Sort(less func(a, b ChannelParticipantLeft) bool) ChannelParticipantLeftArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of ChannelParticipantLeft.
func (s ChannelParticipantLeftArray) SortStable(less func(a, b ChannelParticipantLeft) bool) ChannelParticipantLeftArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of ChannelParticipantLeft.
func (s ChannelParticipantLeftArray) Retain(keep func(x ChannelParticipantLeft) bool) ChannelParticipantLeftArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s ChannelParticipantLeftArray) First() (v ChannelParticipantLeft, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s ChannelParticipantLeftArray) Last() (v ChannelParticipantLeft, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *ChannelParticipantLeftArray) PopFirst() (v ChannelParticipantLeft, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero ChannelParticipantLeft
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *ChannelParticipantLeftArray) Pop() (v ChannelParticipantLeft, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}
