// Code generated by gotdgen, DO NOT EDIT.

package tg

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"github.com/gotd/td/bin"
	"github.com/gotd/td/tdp"
	"github.com/gotd/td/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
)

// MessageEmpty represents TL type `messageEmpty#90a6ca84`.
// Empty constructor, non-existent message.
//
// See https://core.telegram.org/constructor/messageEmpty for reference.
type MessageEmpty struct {
	// Flags field of MessageEmpty.
	Flags bin.Fields
	// Message identifier
	ID int
	// PeerID field of MessageEmpty.
	//
	// Use SetPeerID and GetPeerID helpers.
	PeerID PeerClass
}

// MessageEmptyTypeID is TL type id of MessageEmpty.
const MessageEmptyTypeID = 0x90a6ca84

func (m *MessageEmpty) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Flags.Zero()) {
		return false
	}
	if !(m.ID == 0) {
		return false
	}
	if !(m.PeerID == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageEmpty) String() string {
	if m == nil {
		return "MessageEmpty(nil)"
	}
	type Alias MessageEmpty
	return fmt.Sprintf("MessageEmpty%+v", Alias(*m))
}

// FillFrom fills MessageEmpty from given interface.
func (m *MessageEmpty) FillFrom(from interface {
	GetID() (value int)
	GetPeerID() (value PeerClass, ok bool)
}) {
	m.ID = from.GetID()
	if val, ok := from.GetPeerID(); ok {
		m.PeerID = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageEmpty) TypeID() uint32 {
	return MessageEmptyTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageEmpty) TypeName() string {
	return "messageEmpty"
}

// TypeInfo returns info about TL type.
func (m *MessageEmpty) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageEmpty",
		ID:   MessageEmptyTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ID",
			SchemaName: "id",
		},
		{
			Name:       "PeerID",
			SchemaName: "peer_id",
			Null:       !m.Flags.Has(0),
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageEmpty) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageEmpty#90a6ca84 as nil")
	}
	b.PutID(MessageEmptyTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageEmpty) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageEmpty#90a6ca84 as nil")
	}
	if !(m.PeerID == nil) {
		m.Flags.Set(0)
	}
	if err := m.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageEmpty#90a6ca84: field flags: %w", err)
	}
	b.PutInt(m.ID)
	if m.Flags.Has(0) {
		if m.PeerID == nil {
			return fmt.Errorf("unable to encode messageEmpty#90a6ca84: field peer_id is nil")
		}
		if err := m.PeerID.Encode(b); err != nil {
			return fmt.Errorf("unable to encode messageEmpty#90a6ca84: field peer_id: %w", err)
		}
	}
	return nil
}

// GetID returns value of ID field.
func (m *MessageEmpty) GetID() (value int) {
	return m.ID
}

// SetPeerID sets value of PeerID conditional field.
func (m *MessageEmpty) SetPeerID(value PeerClass) {
	m.Flags.Set(0)
	m.PeerID = value
}

// GetPeerID returns value of PeerID conditional field and
// boolean which is true if field was set.
func (m *MessageEmpty) GetPeerID() (value PeerClass, ok bool) {
	if !m.Flags.Has(0) {
		return value, false
	}
	return m.PeerID, true
}

// Decode implements bin.Decoder.
func (m *MessageEmpty) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageEmpty#90a6ca84 to nil")
	}
	if err := b.ConsumeID(MessageEmptyTypeID); err != nil {
		return fmt.Errorf("unable to decode messageEmpty#90a6ca84: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageEmpty) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageEmpty#90a6ca84 to nil")
	}
	{
		if err := m.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageEmpty#90a6ca84: field flags: %w", err)
		}
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messageEmpty#90a6ca84: field id: %w", err)
		}
		m.ID = value
	}
	if m.Flags.Has(0) {
		value, err := DecodePeer(b)
		if err != nil {
			return fmt.Errorf("unable to decode messageEmpty#90a6ca84: field peer_id: %w", err)
		}
		m.PeerID = value
	}
	return nil
}

// construct implements constructor of MessageClass.
func (m MessageEmpty) construct() MessageClass { return &m }

// Ensuring interfaces in compile-time for MessageEmpty.
var (
	_ bin.Encoder     = &MessageEmpty{}
	_ bin.Decoder     = &MessageEmpty{}
	_ bin.BareEncoder = &MessageEmpty{}
	_ bin.BareDecoder = &MessageEmpty{}

	_ MessageClass = &MessageEmpty{}
)

// Message represents TL type `message#85d6cbe2`.
// A message
//
// See https://core.telegram.org/constructor/message for reference.
type Message struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Is this an outgoing message
	Out bool
	// Whether we were mentioned¹ in this message
	//
	// Links:
	//  1) https://core.telegram.org/api/mentions
	Mentioned bool
	// Whether there are unread media attachments in this message
	MediaUnread bool
	// Whether this is a silent message (no notification triggered)
	Silent bool
	// Whether this is a channel post
	Post bool
	// Whether this is a scheduled message¹
	//
	// Links:
	//  1) https://core.telegram.org/api/scheduled-messages
	FromScheduled bool
	// This is a legacy message: it has to be refetched with the new layer
	Legacy bool
	// Whether the message should be shown as not modified to the user, even if an edit date
	// is present
	EditHide bool
	// Whether this message is pinned¹
	//
	// Links:
	//  1) https://core.telegram.org/api/pin
	Pinned bool
	// ID of the message
	ID int
	// ID of the sender of the message
	//
	// Use SetFromID and GetFromID helpers.
	FromID PeerClass
	// Peer ID, the chat where this message was sent
	PeerID PeerClass
	// Info about forwarded messages
	//
	// Use SetFwdFrom and GetFwdFrom helpers.
	FwdFrom MessageFwdHeader
	// ID of the inline bot that generated the message
	//
	// Use SetViaBotID and GetViaBotID helpers.
	ViaBotID int64
	// Reply information
	//
	// Use SetReplyTo and GetReplyTo helpers.
	ReplyTo MessageReplyHeader
	// Date of the message
	Date int
	// The message
	Message string
	// Media attachment
	//
	// Use SetMedia and GetMedia helpers.
	Media MessageMediaClass
	// Reply markup (bot/inline keyboards)
	//
	// Use SetReplyMarkup and GetReplyMarkup helpers.
	ReplyMarkup ReplyMarkupClass
	// Message entities¹ for styled text
	//
	// Links:
	//  1) https://core.telegram.org/api/entities
	//
	// Use SetEntities and GetEntities helpers.
	Entities []MessageEntityClass
	// View count for channel posts
	//
	// Use SetViews and GetViews helpers.
	Views int
	// Forward counter
	//
	// Use SetForwards and GetForwards helpers.
	Forwards int
	// Info about post comments (for channels) or message replies (for groups)¹
	//
	// Links:
	//  1) https://core.telegram.org/api/threads
	//
	// Use SetReplies and GetReplies helpers.
	Replies MessageReplies
	// Last edit date of this message
	//
	// Use SetEditDate and GetEditDate helpers.
	EditDate int
	// Name of the author of this message for channel posts (with signatures enabled)
	//
	// Use SetPostAuthor and GetPostAuthor helpers.
	PostAuthor string
	// Multiple media messages sent using messages.sendMultiMedia¹ with the same grouped ID
	// indicate an album or media group²
	//
	// Links:
	//  1) https://core.telegram.org/method/messages.sendMultiMedia
	//  2) https://core.telegram.org/api/files#albums-grouped-media
	//
	// Use SetGroupedID and GetGroupedID helpers.
	GroupedID int64
	// Contains the reason why access to this message must be restricted.
	//
	// Use SetRestrictionReason and GetRestrictionReason helpers.
	RestrictionReason []RestrictionReason
	// TTLPeriod field of Message.
	//
	// Use SetTTLPeriod and GetTTLPeriod helpers.
	TTLPeriod int
}

// MessageTypeID is TL type id of Message.
const MessageTypeID = 0x85d6cbe2

func (m *Message) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Flags.Zero()) {
		return false
	}
	if !(m.Out == false) {
		return false
	}
	if !(m.Mentioned == false) {
		return false
	}
	if !(m.MediaUnread == false) {
		return false
	}
	if !(m.Silent == false) {
		return false
	}
	if !(m.Post == false) {
		return false
	}
	if !(m.FromScheduled == false) {
		return false
	}
	if !(m.Legacy == false) {
		return false
	}
	if !(m.EditHide == false) {
		return false
	}
	if !(m.Pinned == false) {
		return false
	}
	if !(m.ID == 0) {
		return false
	}
	if !(m.FromID == nil) {
		return false
	}
	if !(m.PeerID == nil) {
		return false
	}
	if !(m.FwdFrom.Zero()) {
		return false
	}
	if !(m.ViaBotID == 0) {
		return false
	}
	if !(m.ReplyTo.Zero()) {
		return false
	}
	if !(m.Date == 0) {
		return false
	}
	if !(m.Message == "") {
		return false
	}
	if !(m.Media == nil) {
		return false
	}
	if !(m.ReplyMarkup == nil) {
		return false
	}
	if !(m.Entities == nil) {
		return false
	}
	if !(m.Views == 0) {
		return false
	}
	if !(m.Forwards == 0) {
		return false
	}
	if !(m.Replies.Zero()) {
		return false
	}
	if !(m.EditDate == 0) {
		return false
	}
	if !(m.PostAuthor == "") {
		return false
	}
	if !(m.GroupedID == 0) {
		return false
	}
	if !(m.RestrictionReason == nil) {
		return false
	}
	if !(m.TTLPeriod == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *Message) String() string {
	if m == nil {
		return "Message(nil)"
	}
	type Alias Message
	return fmt.Sprintf("Message%+v", Alias(*m))
}

// FillFrom fills Message from given interface.
func (m *Message) FillFrom(from interface {
	GetOut() (value bool)
	GetMentioned() (value bool)
	GetMediaUnread() (value bool)
	GetSilent() (value bool)
	GetPost() (value bool)
	GetFromScheduled() (value bool)
	GetLegacy() (value bool)
	GetEditHide() (value bool)
	GetPinned() (value bool)
	GetID() (value int)
	GetFromID() (value PeerClass, ok bool)
	GetPeerID() (value PeerClass)
	GetFwdFrom() (value MessageFwdHeader, ok bool)
	GetViaBotID() (value int64, ok bool)
	GetReplyTo() (value MessageReplyHeader, ok bool)
	GetDate() (value int)
	GetMessage() (value string)
	GetMedia() (value MessageMediaClass, ok bool)
	GetReplyMarkup() (value ReplyMarkupClass, ok bool)
	GetEntities() (value []MessageEntityClass, ok bool)
	GetViews() (value int, ok bool)
	GetForwards() (value int, ok bool)
	GetReplies() (value MessageReplies, ok bool)
	GetEditDate() (value int, ok bool)
	GetPostAuthor() (value string, ok bool)
	GetGroupedID() (value int64, ok bool)
	GetRestrictionReason() (value []RestrictionReason, ok bool)
	GetTTLPeriod() (value int, ok bool)
}) {
	m.Out = from.GetOut()
	m.Mentioned = from.GetMentioned()
	m.MediaUnread = from.GetMediaUnread()
	m.Silent = from.GetSilent()
	m.Post = from.GetPost()
	m.FromScheduled = from.GetFromScheduled()
	m.Legacy = from.GetLegacy()
	m.EditHide = from.GetEditHide()
	m.Pinned = from.GetPinned()
	m.ID = from.GetID()
	if val, ok := from.GetFromID(); ok {
		m.FromID = val
	}

	m.PeerID = from.GetPeerID()
	if val, ok := from.GetFwdFrom(); ok {
		m.FwdFrom = val
	}

	if val, ok := from.GetViaBotID(); ok {
		m.ViaBotID = val
	}

	if val, ok := from.GetReplyTo(); ok {
		m.ReplyTo = val
	}

	m.Date = from.GetDate()
	m.Message = from.GetMessage()
	if val, ok := from.GetMedia(); ok {
		m.Media = val
	}

	if val, ok := from.GetReplyMarkup(); ok {
		m.ReplyMarkup = val
	}

	if val, ok := from.GetEntities(); ok {
		m.Entities = val
	}

	if val, ok := from.GetViews(); ok {
		m.Views = val
	}

	if val, ok := from.GetForwards(); ok {
		m.Forwards = val
	}

	if val, ok := from.GetReplies(); ok {
		m.Replies = val
	}

	if val, ok := from.GetEditDate(); ok {
		m.EditDate = val
	}

	if val, ok := from.GetPostAuthor(); ok {
		m.PostAuthor = val
	}

	if val, ok := from.GetGroupedID(); ok {
		m.GroupedID = val
	}

	if val, ok := from.GetRestrictionReason(); ok {
		m.RestrictionReason = val
	}

	if val, ok := from.GetTTLPeriod(); ok {
		m.TTLPeriod = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*Message) TypeID() uint32 {
	return MessageTypeID
}

// TypeName returns name of type in TL schema.
func (*Message) TypeName() string {
	return "message"
}

// TypeInfo returns info about TL type.
func (m *Message) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "message",
		ID:   MessageTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Out",
			SchemaName: "out",
			Null:       !m.Flags.Has(1),
		},
		{
			Name:       "Mentioned",
			SchemaName: "mentioned",
			Null:       !m.Flags.Has(4),
		},
		{
			Name:       "MediaUnread",
			SchemaName: "media_unread",
			Null:       !m.Flags.Has(5),
		},
		{
			Name:       "Silent",
			SchemaName: "silent",
			Null:       !m.Flags.Has(13),
		},
		{
			Name:       "Post",
			SchemaName: "post",
			Null:       !m.Flags.Has(14),
		},
		{
			Name:       "FromScheduled",
			SchemaName: "from_scheduled",
			Null:       !m.Flags.Has(18),
		},
		{
			Name:       "Legacy",
			SchemaName: "legacy",
			Null:       !m.Flags.Has(19),
		},
		{
			Name:       "EditHide",
			SchemaName: "edit_hide",
			Null:       !m.Flags.Has(21),
		},
		{
			Name:       "Pinned",
			SchemaName: "pinned",
			Null:       !m.Flags.Has(24),
		},
		{
			Name:       "ID",
			SchemaName: "id",
		},
		{
			Name:       "FromID",
			SchemaName: "from_id",
			Null:       !m.Flags.Has(8),
		},
		{
			Name:       "PeerID",
			SchemaName: "peer_id",
		},
		{
			Name:       "FwdFrom",
			SchemaName: "fwd_from",
			Null:       !m.Flags.Has(2),
		},
		{
			Name:       "ViaBotID",
			SchemaName: "via_bot_id",
			Null:       !m.Flags.Has(11),
		},
		{
			Name:       "ReplyTo",
			SchemaName: "reply_to",
			Null:       !m.Flags.Has(3),
		},
		{
			Name:       "Date",
			SchemaName: "date",
		},
		{
			Name:       "Message",
			SchemaName: "message",
		},
		{
			Name:       "Media",
			SchemaName: "media",
			Null:       !m.Flags.Has(9),
		},
		{
			Name:       "ReplyMarkup",
			SchemaName: "reply_markup",
			Null:       !m.Flags.Has(6),
		},
		{
			Name:       "Entities",
			SchemaName: "entities",
			Null:       !m.Flags.Has(7),
		},
		{
			Name:       "Views",
			SchemaName: "views",
			Null:       !m.Flags.Has(10),
		},
		{
			Name:       "Forwards",
			SchemaName: "forwards",
			Null:       !m.Flags.Has(10),
		},
		{
			Name:       "Replies",
			SchemaName: "replies",
			Null:       !m.Flags.Has(23),
		},
		{
			Name:       "EditDate",
			SchemaName: "edit_date",
			Null:       !m.Flags.Has(15),
		},
		{
			Name:       "PostAuthor",
			SchemaName: "post_author",
			Null:       !m.Flags.Has(16),
		},
		{
			Name:       "GroupedID",
			SchemaName: "grouped_id",
			Null:       !m.Flags.Has(17),
		},
		{
			Name:       "RestrictionReason",
			SchemaName: "restriction_reason",
			Null:       !m.Flags.Has(22),
		},
		{
			Name:       "TTLPeriod",
			SchemaName: "ttl_period",
			Null:       !m.Flags.Has(25),
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *Message) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode message#85d6cbe2 as nil")
	}
	b.PutID(MessageTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *Message) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode message#85d6cbe2 as nil")
	}
	if !(m.Out == false) {
		m.Flags.Set(1)
	}
	if !(m.Mentioned == false) {
		m.Flags.Set(4)
	}
	if !(m.MediaUnread == false) {
		m.Flags.Set(5)
	}
	if !(m.Silent == false) {
		m.Flags.Set(13)
	}
	if !(m.Post == false) {
		m.Flags.Set(14)
	}
	if !(m.FromScheduled == false) {
		m.Flags.Set(18)
	}
	if !(m.Legacy == false) {
		m.Flags.Set(19)
	}
	if !(m.EditHide == false) {
		m.Flags.Set(21)
	}
	if !(m.Pinned == false) {
		m.Flags.Set(24)
	}
	if !(m.FromID == nil) {
		m.Flags.Set(8)
	}
	if !(m.FwdFrom.Zero()) {
		m.Flags.Set(2)
	}
	if !(m.ViaBotID == 0) {
		m.Flags.Set(11)
	}
	if !(m.ReplyTo.Zero()) {
		m.Flags.Set(3)
	}
	if !(m.Media == nil) {
		m.Flags.Set(9)
	}
	if !(m.ReplyMarkup == nil) {
		m.Flags.Set(6)
	}
	if !(m.Entities == nil) {
		m.Flags.Set(7)
	}
	if !(m.Views == 0) {
		m.Flags.Set(10)
	}
	if !(m.Forwards == 0) {
		m.Flags.Set(10)
	}
	if !(m.Replies.Zero()) {
		m.Flags.Set(23)
	}
	if !(m.EditDate == 0) {
		m.Flags.Set(15)
	}
	if !(m.PostAuthor == "") {
		m.Flags.Set(16)
	}
	if !(m.GroupedID == 0) {
		m.Flags.Set(17)
	}
	if !(m.RestrictionReason == nil) {
		m.Flags.Set(22)
	}
	if !(m.TTLPeriod == 0) {
		m.Flags.Set(25)
	}
	if err := m.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode message#85d6cbe2: field flags: %w", err)
	}
	b.PutInt(m.ID)
	if m.Flags.Has(8) {
		if m.FromID == nil {
			return fmt.Errorf("unable to encode message#85d6cbe2: field from_id is nil")
		}
		if err := m.FromID.Encode(b); err != nil {
			return fmt.Errorf("unable to encode message#85d6cbe2: field from_id: %w", err)
		}
	}
	if m.PeerID == nil {
		return fmt.Errorf("unable to encode message#85d6cbe2: field peer_id is nil")
	}
	if err := m.PeerID.Encode(b); err != nil {
		return fmt.Errorf("unable to encode message#85d6cbe2: field peer_id: %w", err)
	}
	if m.Flags.Has(2) {
		if err := m.FwdFrom.Encode(b); err != nil {
			return fmt.Errorf("unable to encode message#85d6cbe2: field fwd_from: %w", err)
		}
	}
	if m.Flags.Has(11) {
		b.PutLong(m.ViaBotID)
	}
	if m.Flags.Has(3) {
		if err := m.ReplyTo.Encode(b); err != nil {
			return fmt.Errorf("unable to encode message#85d6cbe2: field reply_to: %w", err)
		}
	}
	b.PutInt(m.Date)
	b.PutString(m.Message)
	if m.Flags.Has(9) {
		if m.Media == nil {
			return fmt.Errorf("unable to encode message#85d6cbe2: field media is nil")
		}
		if err := m.Media.Encode(b); err != nil {
			return fmt.Errorf("unable to encode message#85d6cbe2: field media: %w", err)
		}
	}
	if m.Flags.Has(6) {
		if m.ReplyMarkup == nil {
			return fmt.Errorf("unable to encode message#85d6cbe2: field reply_markup is nil")
		}
		if err := m.ReplyMarkup.Encode(b); err != nil {
			return fmt.Errorf("unable to encode message#85d6cbe2: field reply_markup: %w", err)
		}
	}
	if m.Flags.Has(7) {
		b.PutVectorHeader(len(m.Entities))
		for idx, v := range m.Entities {
			if v == nil {
				return fmt.Errorf("unable to encode message#85d6cbe2: field entities element with index %d is nil", idx)
			}
			if err := v.Encode(b); err != nil {
				return fmt.Errorf("unable to encode message#85d6cbe2: field entities element with index %d: %w", idx, err)
			}
		}
	}
	if m.Flags.Has(10) {
		b.PutInt(m.Views)
	}
	if m.Flags.Has(10) {
		b.PutInt(m.Forwards)
	}
	if m.Flags.Has(23) {
		if err := m.Replies.Encode(b); err != nil {
			return fmt.Errorf("unable to encode message#85d6cbe2: field replies: %w", err)
		}
	}
	if m.Flags.Has(15) {
		b.PutInt(m.EditDate)
	}
	if m.Flags.Has(16) {
		b.PutString(m.PostAuthor)
	}
	if m.Flags.Has(17) {
		b.PutLong(m.GroupedID)
	}
	if m.Flags.Has(22) {
		b.PutVectorHeader(len(m.RestrictionReason))
		for idx, v := range m.RestrictionReason {
			if err := v.Encode(b); err != nil {
				return fmt.Errorf("unable to encode message#85d6cbe2: field restriction_reason element with index %d: %w", idx, err)
			}
		}
	}
	if m.Flags.Has(25) {
		b.PutInt(m.TTLPeriod)
	}
	return nil
}

// SetOut sets value of Out conditional field.
func (m *Message) SetOut(value bool) {
	if value {
		m.Flags.Set(1)
		m.Out = true
	} else {
		m.Flags.Unset(1)
		m.Out = false
	}
}

// GetOut returns value of Out conditional field.
func (m *Message) GetOut() (value bool) {
	return m.Flags.Has(1)
}

// SetMentioned sets value of Mentioned conditional field.
func (m *Message) SetMentioned(value bool) {
	if value {
		m.Flags.Set(4)
		m.Mentioned = true
	} else {
		m.Flags.Unset(4)
		m.Mentioned = false
	}
}

// GetMentioned returns value of Mentioned conditional field.
func (m *Message) GetMentioned() (value bool) {
	return m.Flags.Has(4)
}

// SetMediaUnread sets value of MediaUnread conditional field.
func (m *Message) SetMediaUnread(value bool) {
	if value {
		m.Flags.Set(5)
		m.MediaUnread = true
	} else {
		m.Flags.Unset(5)
		m.MediaUnread = false
	}
}

// GetMediaUnread returns value of MediaUnread conditional field.
func (m *Message) GetMediaUnread() (value bool) {
	return m.Flags.Has(5)
}

// SetSilent sets value of Silent conditional field.
func (m *Message) SetSilent(value bool) {
	if value {
		m.Flags.Set(13)
		m.Silent = true
	} else {
		m.Flags.Unset(13)
		m.Silent = false
	}
}

// GetSilent returns value of Silent conditional field.
func (m *Message) GetSilent() (value bool) {
	return m.Flags.Has(13)
}

// SetPost sets value of Post conditional field.
func (m *Message) SetPost(value bool) {
	if value {
		m.Flags.Set(14)
		m.Post = true
	} else {
		m.Flags.Unset(14)
		m.Post = false
	}
}

// GetPost returns value of Post conditional field.
func (m *Message) GetPost() (value bool) {
	return m.Flags.Has(14)
}

// SetFromScheduled sets value of FromScheduled conditional field.
func (m *Message) SetFromScheduled(value bool) {
	if value {
		m.Flags.Set(18)
		m.FromScheduled = true
	} else {
		m.Flags.Unset(18)
		m.FromScheduled = false
	}
}

// GetFromScheduled returns value of FromScheduled conditional field.
func (m *Message) GetFromScheduled() (value bool) {
	return m.Flags.Has(18)
}

// SetLegacy sets value of Legacy conditional field.
func (m *Message) SetLegacy(value bool) {
	if value {
		m.Flags.Set(19)
		m.Legacy = true
	} else {
		m.Flags.Unset(19)
		m.Legacy = false
	}
}

// GetLegacy returns value of Legacy conditional field.
func (m *Message) GetLegacy() (value bool) {
	return m.Flags.Has(19)
}

// SetEditHide sets value of EditHide conditional field.
func (m *Message) SetEditHide(value bool) {
	if value {
		m.Flags.Set(21)
		m.EditHide = true
	} else {
		m.Flags.Unset(21)
		m.EditHide = false
	}
}

// GetEditHide returns value of EditHide conditional field.
func (m *Message) GetEditHide() (value bool) {
	return m.Flags.Has(21)
}

// SetPinned sets value of Pinned conditional field.
func (m *Message) SetPinned(value bool) {
	if value {
		m.Flags.Set(24)
		m.Pinned = true
	} else {
		m.Flags.Unset(24)
		m.Pinned = false
	}
}

// GetPinned returns value of Pinned conditional field.
func (m *Message) GetPinned() (value bool) {
	return m.Flags.Has(24)
}

// GetID returns value of ID field.
func (m *Message) GetID() (value int) {
	return m.ID
}

// SetFromID sets value of FromID conditional field.
func (m *Message) SetFromID(value PeerClass) {
	m.Flags.Set(8)
	m.FromID = value
}

// GetFromID returns value of FromID conditional field and
// boolean which is true if field was set.
func (m *Message) GetFromID() (value PeerClass, ok bool) {
	if !m.Flags.Has(8) {
		return value, false
	}
	return m.FromID, true
}

// GetPeerID returns value of PeerID field.
func (m *Message) GetPeerID() (value PeerClass) {
	return m.PeerID
}

// SetFwdFrom sets value of FwdFrom conditional field.
func (m *Message) SetFwdFrom(value MessageFwdHeader) {
	m.Flags.Set(2)
	m.FwdFrom = value
}

// GetFwdFrom returns value of FwdFrom conditional field and
// boolean which is true if field was set.
func (m *Message) GetFwdFrom() (value MessageFwdHeader, ok bool) {
	if !m.Flags.Has(2) {
		return value, false
	}
	return m.FwdFrom, true
}

// SetViaBotID sets value of ViaBotID conditional field.
func (m *Message) SetViaBotID(value int64) {
	m.Flags.Set(11)
	m.ViaBotID = value
}

// GetViaBotID returns value of ViaBotID conditional field and
// boolean which is true if field was set.
func (m *Message) GetViaBotID() (value int64, ok bool) {
	if !m.Flags.Has(11) {
		return value, false
	}
	return m.ViaBotID, true
}

// SetReplyTo sets value of ReplyTo conditional field.
func (m *Message) SetReplyTo(value MessageReplyHeader) {
	m.Flags.Set(3)
	m.ReplyTo = value
}

// GetReplyTo returns value of ReplyTo conditional field and
// boolean which is true if field was set.
func (m *Message) GetReplyTo() (value MessageReplyHeader, ok bool) {
	if !m.Flags.Has(3) {
		return value, false
	}
	return m.ReplyTo, true
}

// GetDate returns value of Date field.
func (m *Message) GetDate() (value int) {
	return m.Date
}

// GetMessage returns value of Message field.
func (m *Message) GetMessage() (value string) {
	return m.Message
}

// SetMedia sets value of Media conditional field.
func (m *Message) SetMedia(value MessageMediaClass) {
	m.Flags.Set(9)
	m.Media = value
}

// GetMedia returns value of Media conditional field and
// boolean which is true if field was set.
func (m *Message) GetMedia() (value MessageMediaClass, ok bool) {
	if !m.Flags.Has(9) {
		return value, false
	}
	return m.Media, true
}

// SetReplyMarkup sets value of ReplyMarkup conditional field.
func (m *Message) SetReplyMarkup(value ReplyMarkupClass) {
	m.Flags.Set(6)
	m.ReplyMarkup = value
}

// GetReplyMarkup returns value of ReplyMarkup conditional field and
// boolean which is true if field was set.
func (m *Message) GetReplyMarkup() (value ReplyMarkupClass, ok bool) {
	if !m.Flags.Has(6) {
		return value, false
	}
	return m.ReplyMarkup, true
}

// SetEntities sets value of Entities conditional field.
func (m *Message) SetEntities(value []MessageEntityClass) {
	m.Flags.Set(7)
	m.Entities = value
}

// GetEntities returns value of Entities conditional field and
// boolean which is true if field was set.
func (m *Message) GetEntities() (value []MessageEntityClass, ok bool) {
	if !m.Flags.Has(7) {
		return value, false
	}
	return m.Entities, true
}

// MapEntities returns field Entities wrapped in MessageEntityClassArray helper.
func (m *Message) MapEntities() (value MessageEntityClassArray, ok bool) {
	if !m.Flags.Has(7) {
		return value, false
	}
	return MessageEntityClassArray(m.Entities), true
}

// SetViews sets value of Views conditional field.
func (m *Message) SetViews(value int) {
	m.Flags.Set(10)
	m.Views = value
}

// GetViews returns value of Views conditional field and
// boolean which is true if field was set.
func (m *Message) GetViews() (value int, ok bool) {
	if !m.Flags.Has(10) {
		return value, false
	}
	return m.Views, true
}

// SetForwards sets value of Forwards conditional field.
func (m *Message) SetForwards(value int) {
	m.Flags.Set(10)
	m.Forwards = value
}

// GetForwards returns value of Forwards conditional field and
// boolean which is true if field was set.
func (m *Message) GetForwards() (value int, ok bool) {
	if !m.Flags.Has(10) {
		return value, false
	}
	return m.Forwards, true
}

// SetReplies sets value of Replies conditional field.
func (m *Message) SetReplies(value MessageReplies) {
	m.Flags.Set(23)
	m.Replies = value
}

// GetReplies returns value of Replies conditional field and
// boolean which is true if field was set.
func (m *Message) GetReplies() (value MessageReplies, ok bool) {
	if !m.Flags.Has(23) {
		return value, false
	}
	return m.Replies, true
}

// SetEditDate sets value of EditDate conditional field.
func (m *Message) SetEditDate(value int) {
	m.Flags.Set(15)
	m.EditDate = value
}

// GetEditDate returns value of EditDate conditional field and
// boolean which is true if field was set.
func (m *Message) GetEditDate() (value int, ok bool) {
	if !m.Flags.Has(15) {
		return value, false
	}
	return m.EditDate, true
}

// SetPostAuthor sets value of PostAuthor conditional field.
func (m *Message) SetPostAuthor(value string) {
	m.Flags.Set(16)
	m.PostAuthor = value
}

// GetPostAuthor returns value of PostAuthor conditional field and
// boolean which is true if field was set.
func (m *Message) GetPostAuthor() (value string, ok bool) {
	if !m.Flags.Has(16) {
		return value, false
	}
	return m.PostAuthor, true
}

// SetGroupedID sets value of GroupedID conditional field.
func (m *Message) SetGroupedID(value int64) {
	m.Flags.Set(17)
	m.GroupedID = value
}

// GetGroupedID returns value of GroupedID conditional field and
// boolean which is true if field was set.
func (m *Message) GetGroupedID() (value int64, ok bool) {
	if !m.Flags.Has(17) {
		return value, false
	}
	return m.GroupedID, true
}

// SetRestrictionReason sets value of RestrictionReason conditional field.
func (m *Message) SetRestrictionReason(value []RestrictionReason) {
	m.Flags.Set(22)
	m.RestrictionReason = value
}

// GetRestrictionReason returns value of RestrictionReason conditional field and
// boolean which is true if field was set.
func (m *Message) GetRestrictionReason() (value []RestrictionReason, ok bool) {
	if !m.Flags.Has(22) {
		return value, false
	}
	return m.RestrictionReason, true
}

// SetTTLPeriod sets value of TTLPeriod conditional field.
func (m *Message) SetTTLPeriod(value int) {
	m.Flags.Set(25)
	m.TTLPeriod = value
}

// GetTTLPeriod returns value of TTLPeriod conditional field and
// boolean which is true if field was set.
func (m *Message) GetTTLPeriod() (value int, ok bool) {
	if !m.Flags.Has(25) {
		return value, false
	}
	return m.TTLPeriod, true
}

// Decode implements bin.Decoder.
func (m *Message) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode message#85d6cbe2 to nil")
	}
	if err := b.ConsumeID(MessageTypeID); err != nil {
		return fmt.Errorf("unable to decode message#85d6cbe2: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *Message) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode message#85d6cbe2 to nil")
	}
	{
		if err := m.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode message#85d6cbe2: field flags: %w", err)
		}
	}
	m.Out = m.Flags.Has(1)
	m.Mentioned = m.Flags.Has(4)
	m.MediaUnread = m.Flags.Has(5)
	m.Silent = m.Flags.Has(13)
	m.Post = m.Flags.Has(14)
	m.FromScheduled = m.Flags.Has(18)
	m.Legacy = m.Flags.Has(19)
	m.EditHide = m.Flags.Has(21)
	m.Pinned = m.Flags.Has(24)
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode message#85d6cbe2: field id: %w", err)
		}
		m.ID = value
	}
	if m.Flags.Has(8) {
		value, err := DecodePeer(b)
		if err != nil {
			return fmt.Errorf("unable to decode message#85d6cbe2: field from_id: %w", err)
		}
		m.FromID = value
	}
	{
		value, err := DecodePeer(b)
		if err != nil {
			return fmt.Errorf("unable to decode message#85d6cbe2: field peer_id: %w", err)
		}
		m.PeerID = value
	}
	if m.Flags.Has(2) {
		if err := m.FwdFrom.Decode(b); err != nil {
			return fmt.Errorf("unable to decode message#85d6cbe2: field fwd_from: %w", err)
		}
	}
	if m.Flags.Has(11) {
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode message#85d6cbe2: field via_bot_id: %w", err)
		}
		m.ViaBotID = value
	}
	if m.Flags.Has(3) {
		if err := m.ReplyTo.Decode(b); err != nil {
			return fmt.Errorf("unable to decode message#85d6cbe2: field reply_to: %w", err)
		}
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode message#85d6cbe2: field date: %w", err)
		}
		m.Date = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode message#85d6cbe2: field message: %w", err)
		}
		m.Message = value
	}
	if m.Flags.Has(9) {
		value, err := DecodeMessageMedia(b)
		if err != nil {
			return fmt.Errorf("unable to decode message#85d6cbe2: field media: %w", err)
		}
		m.Media = value
	}
	if m.Flags.Has(6) {
		value, err := DecodeReplyMarkup(b)
		if err != nil {
			return fmt.Errorf("unable to decode message#85d6cbe2: field reply_markup: %w", err)
		}
		m.ReplyMarkup = value
	}
	if m.Flags.Has(7) {
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode message#85d6cbe2: field entities: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeMessageEntity(b)
			if err != nil {
				return fmt.Errorf("unable to decode message#85d6cbe2: field entities: %w", err)
			}
			m.Entities = append(m.Entities, value)
		}
	}
	if m.Flags.Has(10) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode message#85d6cbe2: field views: %w", err)
		}
		m.Views = value
	}
	if m.Flags.Has(10) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode message#85d6cbe2: field forwards: %w", err)
		}
		m.Forwards = value
	}
	if m.Flags.Has(23) {
		if err := m.Replies.Decode(b); err != nil {
			return fmt.Errorf("unable to decode message#85d6cbe2: field replies: %w", err)
		}
	}
	if m.Flags.Has(15) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode message#85d6cbe2: field edit_date: %w", err)
		}
		m.EditDate = value
	}
	if m.Flags.Has(16) {
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode message#85d6cbe2: field post_author: %w", err)
		}
		m.PostAuthor = value
	}
	if m.Flags.Has(17) {
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode message#85d6cbe2: field grouped_id: %w", err)
		}
		m.GroupedID = value
	}
	if m.Flags.Has(22) {
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode message#85d6cbe2: field restriction_reason: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			var value RestrictionReason
			if err := value.Decode(b); err != nil {
				return fmt.Errorf("unable to decode message#85d6cbe2: field restriction_reason: %w", err)
			}
			m.RestrictionReason = append(m.RestrictionReason, value)
		}
	}
	if m.Flags.Has(25) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode message#85d6cbe2: field ttl_period: %w", err)
		}
		m.TTLPeriod = value
	}
	return nil
}

// construct implements constructor of MessageClass.
func (m Message) construct() MessageClass { return &m }

// Ensuring interfaces in compile-time for Message.
var (
	_ bin.Encoder     = &Message{}
	_ bin.Decoder     = &Message{}
	_ bin.BareEncoder = &Message{}
	_ bin.BareDecoder = &Message{}

	_ MessageClass = &Message{}
)

// MessageService represents TL type `messageService#2b085862`.
// Indicates a service message
//
// See https://core.telegram.org/constructor/messageService for reference.
type MessageService struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Whether the message is outgoing
	Out bool
	// Whether we were mentioned in the message
	Mentioned bool
	// Whether the message contains unread media
	MediaUnread bool
	// Whether the message is silent
	Silent bool
	// Whether it's a channel post
	Post bool
	// This is a legacy message: it has to be refetched with the new layer
	Legacy bool
	// Message ID
	ID int
	// ID of the sender of this message
	//
	// Use SetFromID and GetFromID helpers.
	FromID PeerClass
	// Sender of service message
	PeerID PeerClass
	// Reply (thread) information
	//
	// Use SetReplyTo and GetReplyTo helpers.
	ReplyTo MessageReplyHeader
	// Message date
	Date int
	// Event connected with the service message
	Action MessageActionClass
	// TTLPeriod field of MessageService.
	//
	// Use SetTTLPeriod and GetTTLPeriod helpers.
	TTLPeriod int
}

// MessageServiceTypeID is TL type id of MessageService.
const MessageServiceTypeID = 0x2b085862

func (m *MessageService) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Flags.Zero()) {
		return false
	}
	if !(m.Out == false) {
		return false
	}
	if !(m.Mentioned == false) {
		return false
	}
	if !(m.MediaUnread == false) {
		return false
	}
	if !(m.Silent == false) {
		return false
	}
	if !(m.Post == false) {
		return false
	}
	if !(m.Legacy == false) {
		return false
	}
	if !(m.ID == 0) {
		return false
	}
	if !(m.FromID == nil) {
		return false
	}
	if !(m.PeerID == nil) {
		return false
	}
	if !(m.ReplyTo.Zero()) {
		return false
	}
	if !(m.Date == 0) {
		return false
	}
	if !(m.Action == nil) {
		return false
	}
	if !(m.TTLPeriod == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageService) String() string {
	if m == nil {
		return "MessageService(nil)"
	}
	type Alias MessageService
	return fmt.Sprintf("MessageService%+v", Alias(*m))
}

// FillFrom fills MessageService from given interface.
func (m *MessageService) FillFrom(from interface {
	GetOut() (value bool)
	GetMentioned() (value bool)
	GetMediaUnread() (value bool)
	GetSilent() (value bool)
	GetPost() (value bool)
	GetLegacy() (value bool)
	GetID() (value int)
	GetFromID() (value PeerClass, ok bool)
	GetPeerID() (value PeerClass)
	GetReplyTo() (value MessageReplyHeader, ok bool)
	GetDate() (value int)
	GetAction() (value MessageActionClass)
	GetTTLPeriod() (value int, ok bool)
}) {
	m.Out = from.GetOut()
	m.Mentioned = from.GetMentioned()
	m.MediaUnread = from.GetMediaUnread()
	m.Silent = from.GetSilent()
	m.Post = from.GetPost()
	m.Legacy = from.GetLegacy()
	m.ID = from.GetID()
	if val, ok := from.GetFromID(); ok {
		m.FromID = val
	}

	m.PeerID = from.GetPeerID()
	if val, ok := from.GetReplyTo(); ok {
		m.ReplyTo = val
	}

	m.Date = from.GetDate()
	m.Action = from.GetAction()
	if val, ok := from.GetTTLPeriod(); ok {
		m.TTLPeriod = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageService) TypeID() uint32 {
	return MessageServiceTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageService) TypeName() string {
	return "messageService"
}

// TypeInfo returns info about TL type.
func (m *MessageService) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageService",
		ID:   MessageServiceTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Out",
			SchemaName: "out",
			Null:       !m.Flags.Has(1),
		},
		{
			Name:       "Mentioned",
			SchemaName: "mentioned",
			Null:       !m.Flags.Has(4),
		},
		{
			Name:       "MediaUnread",
			SchemaName: "media_unread",
			Null:       !m.Flags.Has(5),
		},
		{
			Name:       "Silent",
			SchemaName: "silent",
			Null:       !m.Flags.Has(13),
		},
		{
			Name:       "Post",
			SchemaName: "post",
			Null:       !m.Flags.Has(14),
		},
		{
			Name:       "Legacy",
			SchemaName: "legacy",
			Null:       !m.Flags.Has(19),
		},
		{
			Name:       "ID",
			SchemaName: "id",
		},
		{
			Name:       "FromID",
			SchemaName: "from_id",
			Null:       !m.Flags.Has(8),
		},
		{
			Name:       "PeerID",
			SchemaName: "peer_id",
		},
		{
			Name:       "ReplyTo",
			SchemaName: "reply_to",
			Null:       !m.Flags.Has(3),
		},
		{
			Name:       "Date",
			SchemaName: "date",
		},
		{
			Name:       "Action",
			SchemaName: "action",
		},
		{
			Name:       "TTLPeriod",
			SchemaName: "ttl_period",
			Null:       !m.Flags.Has(25),
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageService) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageService#2b085862 as nil")
	}
	b.PutID(MessageServiceTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageService) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageService#2b085862 as nil")
	}
	if !(m.Out == false) {
		m.Flags.Set(1)
	}
	if !(m.Mentioned == false) {
		m.Flags.Set(4)
	}
	if !(m.MediaUnread == false) {
		m.Flags.Set(5)
	}
	if !(m.Silent == false) {
		m.Flags.Set(13)
	}
	if !(m.Post == false) {
		m.Flags.Set(14)
	}
	if !(m.Legacy == false) {
		m.Flags.Set(19)
	}
	if !(m.FromID == nil) {
		m.Flags.Set(8)
	}
	if !(m.ReplyTo.Zero()) {
		m.Flags.Set(3)
	}
	if !(m.TTLPeriod == 0) {
		m.Flags.Set(25)
	}
	if err := m.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageService#2b085862: field flags: %w", err)
	}
	b.PutInt(m.ID)
	if m.Flags.Has(8) {
		if m.FromID == nil {
			return fmt.Errorf("unable to encode messageService#2b085862: field from_id is nil")
		}
		if err := m.FromID.Encode(b); err != nil {
			return fmt.Errorf("unable to encode messageService#2b085862: field from_id: %w", err)
		}
	}
	if m.PeerID == nil {
		return fmt.Errorf("unable to encode messageService#2b085862: field peer_id is nil")
	}
	if err := m.PeerID.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageService#2b085862: field peer_id: %w", err)
	}
	if m.Flags.Has(3) {
		if err := m.ReplyTo.Encode(b); err != nil {
			return fmt.Errorf("unable to encode messageService#2b085862: field reply_to: %w", err)
		}
	}
	b.PutInt(m.Date)
	if m.Action == nil {
		return fmt.Errorf("unable to encode messageService#2b085862: field action is nil")
	}
	if err := m.Action.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageService#2b085862: field action: %w", err)
	}
	if m.Flags.Has(25) {
		b.PutInt(m.TTLPeriod)
	}
	return nil
}

// SetOut sets value of Out conditional field.
func (m *MessageService) SetOut(value bool) {
	if value {
		m.Flags.Set(1)
		m.Out = true
	} else {
		m.Flags.Unset(1)
		m.Out = false
	}
}

// GetOut returns value of Out conditional field.
func (m *MessageService) GetOut() (value bool) {
	return m.Flags.Has(1)
}

// SetMentioned sets value of Mentioned conditional field.
func (m *MessageService) SetMentioned(value bool) {
	if value {
		m.Flags.Set(4)
		m.Mentioned = true
	} else {
		m.Flags.Unset(4)
		m.Mentioned = false
	}
}

// GetMentioned returns value of Mentioned conditional field.
func (m *MessageService) GetMentioned() (value bool) {
	return m.Flags.Has(4)
}

// SetMediaUnread sets value of MediaUnread conditional field.
func (m *MessageService) SetMediaUnread(value bool) {
	if value {
		m.Flags.Set(5)
		m.MediaUnread = true
	} else {
		m.Flags.Unset(5)
		m.MediaUnread = false
	}
}

// GetMediaUnread returns value of MediaUnread conditional field.
func (m *MessageService) GetMediaUnread() (value bool) {
	return m.Flags.Has(5)
}

// SetSilent sets value of Silent conditional field.
func (m *MessageService) SetSilent(value bool) {
	if value {
		m.Flags.Set(13)
		m.Silent = true
	} else {
		m.Flags.Unset(13)
		m.Silent = false
	}
}

// GetSilent returns value of Silent conditional field.
func (m *MessageService) GetSilent() (value bool) {
	return m.Flags.Has(13)
}

// SetPost sets value of Post conditional field.
func (m *MessageService) SetPost(value bool) {
	if value {
		m.Flags.Set(14)
		m.Post = true
	} else {
		m.Flags.Unset(14)
		m.Post = false
	}
}

// GetPost returns value of Post conditional field.
func (m *MessageService) GetPost() (value bool) {
	return m.Flags.Has(14)
}

// SetLegacy sets value of Legacy conditional field.
func (m *MessageService) SetLegacy(value bool) {
	if value {
		m.Flags.Set(19)
		m.Legacy = true
	} else {
		m.Flags.Unset(19)
		m.Legacy = false
	}
}

// GetLegacy returns value of Legacy conditional field.
func (m *MessageService) GetLegacy() (value bool) {
	return m.Flags.Has(19)
}

// GetID returns value of ID field.
func (m *MessageService) GetID() (value int) {
	return m.ID
}

// SetFromID sets value of FromID conditional field.
func (m *MessageService) SetFromID(value PeerClass) {
	m.Flags.Set(8)
	m.FromID = value
}

// GetFromID returns value of FromID conditional field and
// boolean which is true if field was set.
func (m *MessageService) GetFromID() (value PeerClass, ok bool) {
	if !m.Flags.Has(8) {
		return value, false
	}
	return m.FromID, true
}

// GetPeerID returns value of PeerID field.
func (m *MessageService) GetPeerID() (value PeerClass) {
	return m.PeerID
}

// SetReplyTo sets value of ReplyTo conditional field.
func (m *MessageService) SetReplyTo(value MessageReplyHeader) {
	m.Flags.Set(3)
	m.ReplyTo = value
}

// GetReplyTo returns value of ReplyTo conditional field and
// boolean which is true if field was set.
func (m *MessageService) GetReplyTo() (value MessageReplyHeader, ok bool) {
	if !m.Flags.Has(3) {
		return value, false
	}
	return m.ReplyTo, true
}

// GetDate returns value of Date field.
func (m *MessageService) GetDate() (value int) {
	return m.Date
}

// GetAction returns value of Action field.
func (m *MessageService) GetAction() (value MessageActionClass) {
	return m.Action
}

// SetTTLPeriod sets value of TTLPeriod conditional field.
func (m *MessageService) SetTTLPeriod(value int) {
	m.Flags.Set(25)
	m.TTLPeriod = value
}

// GetTTLPeriod returns value of TTLPeriod conditional field and
// boolean which is true if field was set.
func (m *MessageService) GetTTLPeriod() (value int, ok bool) {
	if !m.Flags.Has(25) {
		return value, false
	}
	return m.TTLPeriod, true
}

// Decode implements bin.Decoder.
func (m *MessageService) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageService#2b085862 to nil")
	}
	if err := b.ConsumeID(MessageServiceTypeID); err != nil {
		return fmt.Errorf("unable to decode messageService#2b085862: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageService) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageService#2b085862 to nil")
	}
	{
		if err := m.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageService#2b085862: field flags: %w", err)
		}
	}
	m.Out = m.Flags.Has(1)
	m.Mentioned = m.Flags.Has(4)
	m.MediaUnread = m.Flags.Has(5)
	m.Silent = m.Flags.Has(13)
	m.Post = m.Flags.Has(14)
	m.Legacy = m.Flags.Has(19)
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messageService#2b085862: field id: %w", err)
		}
		m.ID = value
	}
	if m.Flags.Has(8) {
		value, err := DecodePeer(b)
		if err != nil {
			return fmt.Errorf("unable to decode messageService#2b085862: field from_id: %w", err)
		}
		m.FromID = value
	}
	{
		value, err := DecodePeer(b)
		if err != nil {
			return fmt.Errorf("unable to decode messageService#2b085862: field peer_id: %w", err)
		}
		m.PeerID = value
	}
	if m.Flags.Has(3) {
		if err := m.ReplyTo.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageService#2b085862: field reply_to: %w", err)
		}
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messageService#2b085862: field date: %w", err)
		}
		m.Date = value
	}
	{
		value, err := DecodeMessageAction(b)
		if err != nil {
			return fmt.Errorf("unable to decode messageService#2b085862: field action: %w", err)
		}
		m.Action = value
	}
	if m.Flags.Has(25) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messageService#2b085862: field ttl_period: %w", err)
		}
		m.TTLPeriod = value
	}
	return nil
}

// construct implements constructor of MessageClass.
func (m MessageService) construct() MessageClass { return &m }

// Ensuring interfaces in compile-time for MessageService.
var (
	_ bin.Encoder     = &MessageService{}
	_ bin.Decoder     = &MessageService{}
	_ bin.BareEncoder = &MessageService{}
	_ bin.BareDecoder = &MessageService{}

	_ MessageClass = &MessageService{}
)

// MessageClass represents Message generic type.
//
// See https://core.telegram.org/type/Message for reference.
//
// Example:
//  g, err := tg.DecodeMessage(buf)
//  if err != nil {
//      panic(err)
//  }
//  switch v := g.(type) {
//  case *tg.MessageEmpty: // messageEmpty#90a6ca84
//  case *tg.Message: // message#85d6cbe2
//  case *tg.MessageService: // messageService#2b085862
//  default: panic(v)
//  }
type MessageClass interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	construct() MessageClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool

	// Message identifier
	GetID() (value int)

	// AsNotEmpty tries to map MessageClass to NotEmptyMessage.
	AsNotEmpty() (NotEmptyMessage, bool)
}

// AsInputMessageID tries to map Message to InputMessageID.
func (m *Message) AsInputMessageID() *InputMessageID {
	value := new(InputMessageID)
	value.ID = m.GetID()

	return value
}

// AsInputMessageReplyTo tries to map Message to InputMessageReplyTo.
func (m *Message) AsInputMessageReplyTo() *InputMessageReplyTo {
	value := new(InputMessageReplyTo)
	value.ID = m.GetID()

	return value
}

// NotEmptyMessage represents NotEmpty subset of MessageClass.
type NotEmptyMessage interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	construct() MessageClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool

	// Is this an outgoing message
	GetOut() (value bool)

	// Whether we were mentioned¹ in this message
	//
	// Links:
	//  1) https://core.telegram.org/api/mentions
	GetMentioned() (value bool)

	// Whether there are unread media attachments in this message
	GetMediaUnread() (value bool)

	// Whether this is a silent message (no notification triggered)
	GetSilent() (value bool)

	// Whether this is a channel post
	GetPost() (value bool)

	// This is a legacy message: it has to be refetched with the new layer
	GetLegacy() (value bool)

	// ID of the message
	GetID() (value int)

	// ID of the sender of the message
	GetFromID() (value PeerClass, ok bool)

	// Peer ID, the chat where this message was sent
	GetPeerID() (value PeerClass)

	// Reply information
	GetReplyTo() (value MessageReplyHeader, ok bool)

	// Date of the message
	GetDate() (value int)

	// TTLPeriod field of Message.
	GetTTLPeriod() (value int, ok bool)
}

// AsNotEmpty tries to map MessageEmpty to NotEmptyMessage.
func (m *MessageEmpty) AsNotEmpty() (NotEmptyMessage, bool) {
	value, ok := (MessageClass(m)).(NotEmptyMessage)
	return value, ok
}

// AsNotEmpty tries to map Message to NotEmptyMessage.
func (m *Message) AsNotEmpty() (NotEmptyMessage, bool) {
	value, ok := (MessageClass(m)).(NotEmptyMessage)
	return value, ok
}

// AsNotEmpty tries to map MessageService to NotEmptyMessage.
func (m *MessageService) AsNotEmpty() (NotEmptyMessage, bool) {
	value, ok := (MessageClass(m)).(NotEmptyMessage)
	return value, ok
}

// DecodeMessage implements binary de-serialization for MessageClass.
func DecodeMessage(buf *bin.Buffer) (MessageClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case MessageEmptyTypeID:
		// Decoding messageEmpty#90a6ca84.
		v := MessageEmpty{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageClass: %w", err)
		}
		return &v, nil
	case MessageTypeID:
		// Decoding message#85d6cbe2.
		v := Message{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageClass: %w", err)
		}
		return &v, nil
	case MessageServiceTypeID:
		// Decoding messageService#2b085862.
		v := MessageService{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode MessageClass: %w", bin.NewUnexpectedID(id))
	}
}

// Message boxes the MessageClass providing a helper.
type MessageBox struct {
	Message MessageClass
}

// Decode implements bin.Decoder for MessageBox.
func (b *MessageBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode MessageBox to nil")
	}
	v, err := DecodeMessage(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.Message = v
	return nil
}

// Encode implements bin.Encode for MessageBox.
func (b *MessageBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.Message == nil {
		return fmt.Errorf("unable to encode MessageClass as nil")
	}
	return b.Message.Encode(buf)
}

// MessageClassArray is adapter for slice of MessageClass.
type MessageClassArray []MessageClass

// Sort sorts slice of MessageClass.
func (s MessageClassArray) Sort(less func(a, b MessageClass) bool) MessageClassArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of MessageClass.
func (s MessageClassArray) SortStable(less func(a, b MessageClass) bool) MessageClassArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of MessageClass.
func (s MessageClassArray) Retain(keep func(x MessageClass) bool) MessageClassArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s MessageClassArray) First() (v MessageClass, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s MessageClassArray) Last() (v MessageClass, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *MessageClassArray) PopFirst() (v MessageClass, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero MessageClass
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *MessageClassArray) Pop() (v MessageClass, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByID sorts slice of MessageClass by ID.
func (s MessageClassArray) SortByID() MessageClassArray {
	return s.Sort(func(a, b MessageClass) bool {
		return a.GetID() < b.GetID()
	})
}

// SortStableByID sorts slice of MessageClass by ID.
func (s MessageClassArray) SortStableByID() MessageClassArray {
	return s.SortStable(func(a, b MessageClass) bool {
		return a.GetID() < b.GetID()
	})
}

// FillMessageEmptyMap fills only MessageEmpty constructors to given map.
func (s MessageClassArray) FillMessageEmptyMap(to map[int]*MessageEmpty) {
	for _, elem := range s {
		value, ok := elem.(*MessageEmpty)
		if !ok {
			continue
		}
		to[value.GetID()] = value
	}
}

// MessageEmptyToMap collects only MessageEmpty constructors to map.
func (s MessageClassArray) MessageEmptyToMap() map[int]*MessageEmpty {
	r := make(map[int]*MessageEmpty, len(s))
	s.FillMessageEmptyMap(r)
	return r
}

// AsMessageEmpty returns copy with only MessageEmpty constructors.
func (s MessageClassArray) AsMessageEmpty() (to MessageEmptyArray) {
	for _, elem := range s {
		value, ok := elem.(*MessageEmpty)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// FillMessageMap fills only Message constructors to given map.
func (s MessageClassArray) FillMessageMap(to map[int]*Message) {
	for _, elem := range s {
		value, ok := elem.(*Message)
		if !ok {
			continue
		}
		to[value.GetID()] = value
	}
}

// MessageToMap collects only Message constructors to map.
func (s MessageClassArray) MessageToMap() map[int]*Message {
	r := make(map[int]*Message, len(s))
	s.FillMessageMap(r)
	return r
}

// AsMessage returns copy with only Message constructors.
func (s MessageClassArray) AsMessage() (to MessageArray) {
	for _, elem := range s {
		value, ok := elem.(*Message)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// FillMessageServiceMap fills only MessageService constructors to given map.
func (s MessageClassArray) FillMessageServiceMap(to map[int]*MessageService) {
	for _, elem := range s {
		value, ok := elem.(*MessageService)
		if !ok {
			continue
		}
		to[value.GetID()] = value
	}
}

// MessageServiceToMap collects only MessageService constructors to map.
func (s MessageClassArray) MessageServiceToMap() map[int]*MessageService {
	r := make(map[int]*MessageService, len(s))
	s.FillMessageServiceMap(r)
	return r
}

// AsMessageService returns copy with only MessageService constructors.
func (s MessageClassArray) AsMessageService() (to MessageServiceArray) {
	for _, elem := range s {
		value, ok := elem.(*MessageService)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// FillNotEmptyMap fills only NotEmpty constructors to given map.
func (s MessageClassArray) FillNotEmptyMap(to map[int]NotEmptyMessage) {
	for _, elem := range s {
		value, ok := elem.AsNotEmpty()
		if !ok {
			continue
		}
		to[value.GetID()] = value
	}
}

// NotEmptyToMap collects only NotEmpty constructors to map.
func (s MessageClassArray) NotEmptyToMap() map[int]NotEmptyMessage {
	r := make(map[int]NotEmptyMessage, len(s))
	s.FillNotEmptyMap(r)
	return r
}

// AppendOnlyNotEmpty appends only NotEmpty constructors to
// given slice.
func (s MessageClassArray) AppendOnlyNotEmpty(to []NotEmptyMessage) []NotEmptyMessage {
	for _, elem := range s {
		value, ok := elem.AsNotEmpty()
		if !ok {
			continue
		}
		to = append(to, value)
	}

	return to
}

// AsNotEmpty returns copy with only NotEmpty constructors.
func (s MessageClassArray) AsNotEmpty() (to []NotEmptyMessage) {
	return s.AppendOnlyNotEmpty(to)
}

// FirstAsNotEmpty returns first element of slice (if exists).
func (s MessageClassArray) FirstAsNotEmpty() (v NotEmptyMessage, ok bool) {
	value, ok := s.First()
	if !ok {
		return
	}
	return value.AsNotEmpty()
}

// LastAsNotEmpty returns last element of slice (if exists).
func (s MessageClassArray) LastAsNotEmpty() (v NotEmptyMessage, ok bool) {
	value, ok := s.Last()
	if !ok {
		return
	}
	return value.AsNotEmpty()
}

// PopFirstAsNotEmpty returns element of slice (if exists).
func (s *MessageClassArray) PopFirstAsNotEmpty() (v NotEmptyMessage, ok bool) {
	value, ok := s.PopFirst()
	if !ok {
		return
	}
	return value.AsNotEmpty()
}

// PopAsNotEmpty returns element of slice (if exists).
func (s *MessageClassArray) PopAsNotEmpty() (v NotEmptyMessage, ok bool) {
	value, ok := s.Pop()
	if !ok {
		return
	}
	return value.AsNotEmpty()
}

// MessageEmptyArray is adapter for slice of MessageEmpty.
type MessageEmptyArray []MessageEmpty

// Sort sorts slice of MessageEmpty.
func (s MessageEmptyArray) Sort(less func(a, b MessageEmpty) bool) MessageEmptyArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of MessageEmpty.
func (s MessageEmptyArray) SortStable(less func(a, b MessageEmpty) bool) MessageEmptyArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of MessageEmpty.
func (s MessageEmptyArray) Retain(keep func(x MessageEmpty) bool) MessageEmptyArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s MessageEmptyArray) First() (v MessageEmpty, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s MessageEmptyArray) Last() (v MessageEmpty, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *MessageEmptyArray) PopFirst() (v MessageEmpty, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero MessageEmpty
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *MessageEmptyArray) Pop() (v MessageEmpty, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByID sorts slice of MessageEmpty by ID.
func (s MessageEmptyArray) SortByID() MessageEmptyArray {
	return s.Sort(func(a, b MessageEmpty) bool {
		return a.GetID() < b.GetID()
	})
}

// SortStableByID sorts slice of MessageEmpty by ID.
func (s MessageEmptyArray) SortStableByID() MessageEmptyArray {
	return s.SortStable(func(a, b MessageEmpty) bool {
		return a.GetID() < b.GetID()
	})
}

// FillMap fills constructors to given map.
func (s MessageEmptyArray) FillMap(to map[int]MessageEmpty) {
	for _, value := range s {
		to[value.GetID()] = value
	}
}

// ToMap collects constructors to map.
func (s MessageEmptyArray) ToMap() map[int]MessageEmpty {
	r := make(map[int]MessageEmpty, len(s))
	s.FillMap(r)
	return r
}

// MessageArray is adapter for slice of Message.
type MessageArray []Message

// Sort sorts slice of Message.
func (s MessageArray) Sort(less func(a, b Message) bool) MessageArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of Message.
func (s MessageArray) SortStable(less func(a, b Message) bool) MessageArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of Message.
func (s MessageArray) Retain(keep func(x Message) bool) MessageArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s MessageArray) First() (v Message, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s MessageArray) Last() (v Message, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *MessageArray) PopFirst() (v Message, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero Message
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *MessageArray) Pop() (v Message, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByID sorts slice of Message by ID.
func (s MessageArray) SortByID() MessageArray {
	return s.Sort(func(a, b Message) bool {
		return a.GetID() < b.GetID()
	})
}

// SortStableByID sorts slice of Message by ID.
func (s MessageArray) SortStableByID() MessageArray {
	return s.SortStable(func(a, b Message) bool {
		return a.GetID() < b.GetID()
	})
}

// SortByDate sorts slice of Message by Date.
func (s MessageArray) SortByDate() MessageArray {
	return s.Sort(func(a, b Message) bool {
		return a.GetDate() < b.GetDate()
	})
}

// SortStableByDate sorts slice of Message by Date.
func (s MessageArray) SortStableByDate() MessageArray {
	return s.SortStable(func(a, b Message) bool {
		return a.GetDate() < b.GetDate()
	})
}

// FillMap fills constructors to given map.
func (s MessageArray) FillMap(to map[int]Message) {
	for _, value := range s {
		to[value.GetID()] = value
	}
}

// ToMap collects constructors to map.
func (s MessageArray) ToMap() map[int]Message {
	r := make(map[int]Message, len(s))
	s.FillMap(r)
	return r
}

// MessageServiceArray is adapter for slice of MessageService.
type MessageServiceArray []MessageService

// Sort sorts slice of MessageService.
func (s MessageServiceArray) Sort(less func(a, b MessageService) bool) MessageServiceArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of MessageService.
func (s MessageServiceArray) SortStable(less func(a, b MessageService) bool) MessageServiceArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of MessageService.
func (s MessageServiceArray) Retain(keep func(x MessageService) bool) MessageServiceArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s MessageServiceArray) First() (v MessageService, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s MessageServiceArray) Last() (v MessageService, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *MessageServiceArray) PopFirst() (v MessageService, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero MessageService
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *MessageServiceArray) Pop() (v MessageService, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SortByID sorts slice of MessageService by ID.
func (s MessageServiceArray) SortByID() MessageServiceArray {
	return s.Sort(func(a, b MessageService) bool {
		return a.GetID() < b.GetID()
	})
}

// SortStableByID sorts slice of MessageService by ID.
func (s MessageServiceArray) SortStableByID() MessageServiceArray {
	return s.SortStable(func(a, b MessageService) bool {
		return a.GetID() < b.GetID()
	})
}

// SortByDate sorts slice of MessageService by Date.
func (s MessageServiceArray) SortByDate() MessageServiceArray {
	return s.Sort(func(a, b MessageService) bool {
		return a.GetDate() < b.GetDate()
	})
}

// SortStableByDate sorts slice of MessageService by Date.
func (s MessageServiceArray) SortStableByDate() MessageServiceArray {
	return s.SortStable(func(a, b MessageService) bool {
		return a.GetDate() < b.GetDate()
	})
}

// FillMap fills constructors to given map.
func (s MessageServiceArray) FillMap(to map[int]MessageService) {
	for _, value := range s {
		to[value.GetID()] = value
	}
}

// ToMap collects constructors to map.
func (s MessageServiceArray) ToMap() map[int]MessageService {
	r := make(map[int]MessageService, len(s))
	s.FillMap(r)
	return r
}
